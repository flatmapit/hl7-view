<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="version" content="1.0.15">
    <title>HL7 Document Viewer</title>
    <!-- GitHub Pages deployment -->
    <style>
        :root {
            --bg-primary: #0f172a;
            --bg-secondary: #1e293b;
            --bg-tertiary: #334155;
            --text-primary: #f1f5f9;
            --text-secondary: #94a3b8;
            --accent: #3b82f6;
            --accent-hover: #2563eb;
            --success: #22c55e;
            --warning: #f59e0b;
            --error: #ef4444;
            --border: #475569;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg-primary);
            color: var(--text-primary);
            min-height: 100vh;
            line-height: 1.6;
        }

        .container {
            max-width: 1800px;
            margin: 0 auto;
            padding: 2rem;
        }

        header {
            text-align: center;
            margin-bottom: 2rem;
            padding-bottom: 1.5rem;
            border-bottom: 1px solid var(--border);
        }

        h1 {
            font-size: 2rem;
            font-weight: 600;
            margin-bottom: 0.5rem;
            background: linear-gradient(135deg, var(--accent), #8b5cf6);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        header p {
            color: var(--text-secondary);
            font-size: 0.95rem;
        }

        .main-content {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 1.5rem;
        }

        @media (max-width: 1024px) {
            .main-content {
                grid-template-columns: 1fr;
            }
        }

        .panel {
            background: var(--bg-secondary);
            border-radius: 12px;
            border: 1px solid var(--border);
            overflow: hidden;
        }

        .panel-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 1rem 1.25rem;
            background: var(--bg-tertiary);
            border-bottom: 1px solid var(--border);
        }

        .panel-title {
            font-size: 0.9rem;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            color: var(--text-secondary);
        }

        .panel-body {
            padding: 1.25rem;
        }

        textarea {
            width: 100%;
            height: 400px;
            background: var(--bg-primary);
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 1rem;
            color: var(--text-primary);
            font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
            font-size: 0.85rem;
            resize: vertical;
            transition: border-color 0.2s;
        }

        textarea:focus {
            outline: none;
            border-color: var(--accent);
        }

        textarea::placeholder {
            color: var(--text-secondary);
            opacity: 0.7;
        }

        .button-group {
            display: flex;
            gap: 0.75rem;
            margin-top: 1rem;
        }

        button {
            padding: 0.75rem 1.5rem;
            border: none;
            border-radius: 8px;
            font-size: 0.9rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
        }

        .btn-primary {
            background: var(--accent);
            color: white;
        }

        .btn-primary:hover {
            background: var(--accent-hover);
            transform: translateY(-1px);
        }

        .btn-secondary {
            background: var(--bg-tertiary);
            color: var(--text-primary);
            border: 1px solid var(--border);
        }

        .btn-secondary:hover {
            background: var(--border);
        }

        .results-panel {
            min-height: 500px;
        }

        .segment-list {
            max-height: 200px;
            overflow-y: auto;
            background: var(--bg-primary);
            border-radius: 8px;
            border: 1px solid var(--border);
            margin-bottom: 1rem;
        }

        .segment-item {
            padding: 0.5rem 0.75rem;
            font-family: monospace;
            font-size: 0.8rem;
            border-bottom: 1px solid var(--border);
            cursor: pointer;
            transition: background 0.15s;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .segment-item:last-child {
            border-bottom: none;
        }

        .segment-item:hover {
            background: var(--bg-tertiary);
        }

        .segment-item.active {
            background: var(--accent);
            color: white;
        }

        .segment-tag {
            background: var(--bg-tertiary);
            padding: 0.15rem 0.5rem;
            border-radius: 4px;
            font-weight: 600;
            font-size: 0.75rem;
        }

        .segment-item.active .segment-tag {
            background: rgba(255,255,255,0.2);
        }

        .documents-section {
            margin-top: 1.5rem;
        }

        .documents-header {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 1rem;
            color: var(--text-secondary);
            font-size: 0.85rem;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        .doc-count {
            background: var(--accent);
            color: white;
            padding: 0.15rem 0.5rem;
            border-radius: 10px;
            font-size: 0.75rem;
        }

        .document-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
            gap: 1rem;
        }

        .document-card {
            background: var(--bg-primary);
            border: 1px solid var(--border);
            border-radius: 10px;
            overflow: hidden;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .document-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(0,0,0,0.3);
        }

        .document-preview {
            position: relative;
            background: #1a1a2e;
            min-height: 180px;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
        }

        .document-preview img {
            max-width: 100%;
            max-height: 250px;
            object-fit: contain;
        }

        .document-preview iframe {
            width: 100%;
            height: 300px;
            border: none;
        }

        .document-preview audio,
        .document-preview video {
            max-width: 100%;
        }

        .pdf-placeholder {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 0.75rem;
            color: var(--text-secondary);
            padding: 2rem;
        }

        .pdf-icon {
            font-size: 3rem;
        }

        .document-info {
            padding: 1rem;
        }

        .document-type {
            display: inline-flex;
            align-items: center;
            gap: 0.35rem;
            padding: 0.25rem 0.6rem;
            border-radius: 5px;
            font-size: 0.75rem;
            font-weight: 600;
            text-transform: uppercase;
            margin-bottom: 0.5rem;
        }

        .type-jpeg, .type-jpg {
            background: rgba(239, 68, 68, 0.2);
            color: #fca5a5;
        }

        .type-png {
            background: rgba(34, 197, 94, 0.2);
            color: #86efac;
        }

        .type-pdf {
            background: rgba(245, 158, 11, 0.2);
            color: #fcd34d;
        }

        .type-gif {
            background: rgba(139, 92, 246, 0.2);
            color: #c4b5fd;
        }

        .type-tiff, .type-tif {
            background: rgba(34, 197, 94, 0.2);
            color: #86efac;
        }

        .type-rtf {
            background: rgba(59, 130, 246, 0.2);
            color: #93c5fd;
        }

        .type-html, .type-htm {
            background: rgba(236, 72, 153, 0.2);
            color: #f9a8d4;
        }

        .type-zip {
            background: rgba(168, 85, 247, 0.2);
            color: #d8b4fe;
        }

        .type-xml {
            background: rgba(14, 165, 233, 0.2);
            color: #7dd3fc;
        }

        .type-svg {
            background: rgba(251, 146, 60, 0.2);
            color: #fed7aa;
        }

        .type-dicom, .type-dcm {
            background: rgba(239, 68, 68, 0.2);
            color: #fca5a5;
        }

        .type-doc {
            background: rgba(37, 99, 235, 0.2);
            color: #93c5fd;
        }

        .type-docx {
            background: rgba(37, 99, 235, 0.2);
            color: #93c5fd;
        }

        .type-mp3 {
            background: rgba(16, 185, 129, 0.2);
            color: #6ee7b7;
        }

        .type-wav, .type-wave {
            background: rgba(16, 185, 129, 0.2);
            color: #6ee7b7;
        }

        .type-mp4 {
            background: rgba(219, 39, 119, 0.2);
            color: #f9a8d4;
        }

        .type-hl7-scp-ecg {
            background: rgba(239, 68, 68, 0.2);
            color: #fca5a5;
        }

        .document-meta {
            font-size: 0.8rem;
            color: var(--text-secondary);
        }

        .document-meta span {
            display: block;
            margin-bottom: 0.25rem;
        }

        .document-actions {
            display: flex;
            gap: 0.5rem;
            margin-top: 0.75rem;
        }

        .document-actions button {
            flex: 1;
            padding: 0.5rem;
            font-size: 0.8rem;
        }

        .empty-state {
            text-align: center;
            padding: 3rem 2rem;
            color: var(--text-secondary);
        }

        .empty-state-icon {
            font-size: 3rem;
            margin-bottom: 1rem;
            opacity: 0.5;
        }

        .empty-state h3 {
            color: var(--text-primary);
            margin-bottom: 0.5rem;
        }

        .stats-bar {
            display: flex;
            gap: 1.5rem;
            padding: 1rem;
            background: var(--bg-primary);
            border-radius: 8px;
            margin-bottom: 1rem;
        }

        .stat-item {
            text-align: center;
        }

        .stat-value {
            font-size: 1.5rem;
            font-weight: 700;
            color: var(--accent);
        }

        .stat-label {
            font-size: 0.75rem;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        .segment-detail {
            background: var(--bg-primary);
            border-radius: 8px;
            border: 1px solid var(--border);
            padding: 1rem;
            margin-top: 1rem;
            font-family: monospace;
            font-size: 0.8rem;
            word-break: break-all;
            max-height: 400px;
            overflow-y: auto;
        }

        .field-highlight {
            color: var(--accent);
        }

        /* Field selection and matching highlights */
        .field-value {
            cursor: pointer;
            padding: 0.1rem 0.2rem;
            border-radius: 3px;
            transition: background 0.15s;
        }

        .field-value:hover {
            background: rgba(59, 130, 246, 0.15);
        }

        .field-value.selected {
            background: var(--accent);
            color: white;
        }

        .field-value.matching {
            background: rgba(245, 158, 11, 0.3);
            border: 1px solid var(--warning);
        }

        .field-value.selected.matching {
            background: var(--accent);
            color: white;
            border: 1px solid var(--accent);
        }

        /* Segment list item matching highlight */
        .segment-item.has-match {
            background: rgba(245, 158, 11, 0.15);
            border-left: 3px solid var(--warning);
        }

        .segment-item.has-match:hover {
            background: rgba(245, 158, 11, 0.25);
        }

        .segment-item.active.has-match {
            background: var(--accent);
            border-left: 3px solid white;
        }

        /* Input panel highlighting container */
        .input-highlight-container {
            position: relative;
            width: 100%;
        }

        .input-highlight-backdrop {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: var(--bg-primary);
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 1rem;
            font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
            font-size: 0.85rem;
            line-height: 1.6;
            color: var(--text-primary);
            overflow-y: auto;
            white-space: pre-wrap;
            word-break: break-all;
            pointer-events: none;
            z-index: 1;
        }

        .input-highlight-backdrop .hl7-match {
            background: rgba(245, 158, 11, 0.4);
            border-radius: 2px;
            padding: 0 2px;
        }

        .input-panel textarea {
            position: relative;
            z-index: 2;
            background: var(--bg-primary);
        }

        .input-panel textarea.highlight-active {
            background: transparent;
            color: transparent;
            caret-color: var(--text-primary);
        }

        /* Clear highlight button */
        .clear-highlight-btn {
            display: none;
            position: absolute;
            top: 0.5rem;
            right: 0.5rem;
            z-index: 3;
            padding: 0.4rem 0.8rem;
            font-size: 0.75rem;
            background: var(--warning);
            color: #000;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .clear-highlight-btn:hover {
            background: #d97706;
        }

        .clear-highlight-btn.visible {
            display: block;
        }

        .segment-header {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 0.75rem;
            padding-bottom: 0.5rem;
            border-bottom: 1px solid var(--border);
        }

        .segment-type-header {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-weight: 600;
            font-size: 0.9rem;
        }

        .copy-icon {
            cursor: pointer;
            padding: 0.25rem 0.5rem;
            border-radius: 4px;
            background: var(--bg-tertiary);
            border: 1px solid var(--border);
            display: inline-flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
            font-size: 0.75rem;
            color: var(--text-secondary);
        }

        .copy-icon:hover {
            background: var(--accent);
            color: white;
            border-color: var(--accent);
        }

        .copy-icon svg {
            width: 14px;
            height: 14px;
        }

        .field-item {
            display: flex;
            align-items: flex-start;
            gap: 0.5rem;
            padding: 0.5rem 0;
            border-bottom: 1px solid rgba(71, 85, 105, 0.3);
        }

        .field-item:last-child {
            border-bottom: none;
        }

        .field-index {
            color: var(--text-secondary);
            font-weight: 600;
            min-width: 50px;
            font-size: 0.75rem;
        }

        .field-name {
            color: var(--accent);
            font-weight: 500;
            min-width: 180px;
            max-width: 220px;
            font-size: 0.75rem;
            font-style: italic;
            margin-right: 0.5rem;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            flex-shrink: 0;
        }

        .field-content {
            flex: 1;
            word-break: break-word;
            overflow-wrap: break-word;
        }

        .field-content.long {
            max-width: 100%;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .field-content.expanded {
            white-space: normal;
            word-break: break-all;
            overflow: visible;
            text-overflow: clip;
        }

        .field-copy {
            flex-shrink: 0;
        }

        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.85);
            z-index: 1000;
            align-items: center;
            justify-content: center;
            padding: 2rem;
        }

        .modal.active {
            display: flex;
        }

        .modal-content {
            max-width: 90vw;
            max-height: 90vh;
            position: relative;
        }

        .modal-content img {
            max-width: 100%;
            max-height: 85vh;
            border-radius: 8px;
        }

        .modal-content iframe {
            width: 80vw;
            height: 85vh;
            border: none;
            border-radius: 8px;
        }

        .modal-close {
            position: absolute;
            top: -40px;
            right: 0;
            background: var(--bg-tertiary);
            border: none;
            color: white;
            width: 36px;
            height: 36px;
            border-radius: 50%;
            cursor: pointer;
            font-size: 1.2rem;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .modal-close:hover {
            background: var(--error);
        }

        .results-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.95);
            z-index: 1000;
            padding: 2rem;
            overflow-y: auto;
        }

        .results-overlay.active {
            display: block;
        }

        .results-overlay-content {
            max-width: 90vw;
            width: 1400px;
            margin: 0 auto;
            background: var(--bg-secondary);
            border-radius: 12px;
            border: 1px solid var(--border);
            overflow: hidden;
            max-height: calc(100vh - 4rem);
            display: flex;
            flex-direction: column;
        }

        .overlay-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 1.5rem 2rem;
            background: var(--bg-tertiary);
            border-bottom: 1px solid var(--border);
        }

        .overlay-header h2 {
            font-size: 1.5rem;
            font-weight: 600;
            color: var(--text-primary);
            margin: 0;
        }

        .overlay-stats-bar {
            display: flex;
            gap: 2rem;
            padding: 1.5rem 2rem;
            background: var(--bg-primary);
            border-bottom: 1px solid var(--border);
        }

        .overlay-segments-container {
            padding: 2rem;
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 1.5rem;
            flex: 1;
            min-height: 0;
        }

        .overlay-segment-list {
            max-height: 100%;
            overflow-y: auto;
            background: var(--bg-primary);
            border-radius: 8px;
            border: 1px solid var(--border);
        }

        .overlay-segment-item {
            padding: 0.75rem 1rem;
            font-family: monospace;
            font-size: 0.9rem;
            border-bottom: 1px solid var(--border);
            cursor: pointer;
            transition: background 0.15s;
            display: flex;
            align-items: center;
            gap: 0.75rem;
        }

        .overlay-segment-item:last-child {
            border-bottom: none;
        }

        .overlay-segment-item:hover {
            background: var(--bg-tertiary);
        }

        .overlay-segment-item.active {
            background: var(--accent);
            color: white;
        }

        .overlay-segment-item.has-match {
            background: rgba(245, 158, 11, 0.15);
            border-left: 3px solid var(--warning);
        }

        .overlay-segment-item.has-match:hover {
            background: rgba(245, 158, 11, 0.25);
        }

        .overlay-segment-item.active.has-match {
            background: var(--accent);
            border-left: 3px solid white;
        }

        .overlay-segment-detail {
            background: var(--bg-primary);
            border-radius: 8px;
            border: 1px solid var(--border);
            padding: 1.5rem;
            font-family: monospace;
            font-size: 0.9rem;
            word-break: break-all;
            max-height: 100%;
            overflow-y: auto;
        }

        @media (max-width: 1200px) {
            .overlay-segments-container {
                grid-template-columns: 1fr;
            }
        }

        /* Scrollbar styling */
        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }

        ::-webkit-scrollbar-track {
            background: var(--bg-primary);
        }

        ::-webkit-scrollbar-thumb {
            background: var(--border);
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: var(--text-secondary);
        }

        .toast {
            position: fixed;
            bottom: 2rem;
            right: 2rem;
            background: var(--bg-tertiary);
            color: var(--text-primary);
            padding: 1rem 1.5rem;
            border-radius: 8px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.3);
            transform: translateY(100px);
            opacity: 0;
            transition: all 0.3s;
            z-index: 1001;
        }

        .toast.show {
            transform: translateY(0);
            opacity: 1;
        }

        .toast.success {
            border-left: 4px solid var(--success);
        }

        .toast.error {
            border-left: 4px solid var(--error);
        }

        footer {
            margin-top: 3rem;
            padding-top: 2rem;
            border-top: 1px solid var(--border);
            text-align: center;
            color: var(--text-secondary);
            font-size: 0.85rem;
        }

        footer a {
            color: var(--accent);
            text-decoration: none;
            transition: color 0.2s;
        }

        footer a:hover {
            color: var(--accent-hover);
            text-decoration: underline;
        }

        .footer-content {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
            align-items: center;
        }

        @media (min-width: 768px) {
            .footer-content {
                flex-direction: row;
                justify-content: center;
                gap: 1rem;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>HL7 Document Viewer <span style="font-size: 0.6em; font-weight: normal; color: var(--text-secondary);">v<span id="headerVersion">1.0.15</span></span></h1>
            <p>Parse HL7 messages and extract embedded documents (Images, PDFs, Audio, Video, Documents, and more)</p>
            <p style="font-size: 0.85rem; color: var(--text-secondary); margin-top: 0.5rem;">All processing happens locally in your browser - your data never leaves your device</p>
        </header>

        <div class="main-content">
            <div class="panel input-panel">
                <div class="panel-header">
                    <span class="panel-title">HL7 Message Input</span>
                </div>
                <div class="panel-body">
                    <div class="input-highlight-container">
                        <div class="input-highlight-backdrop" id="inputHighlightBackdrop"></div>
                        <textarea id="hl7Input" placeholder="Paste your HL7 message here...

Example OBX segment with embedded document:
OBX|1|ED|PDF^Document||^application^pdf^Base64^JVBERi0xLjQKJ...||||||F"></textarea>
                        <button class="clear-highlight-btn" id="clearHighlightBtn" onclick="clearFieldHighlight()">Clear Highlight</button>
                    </div>
                    <div class="button-group">
                        <button class="btn-primary" onclick="parseHL7()">
                            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"></path>
                                <polyline points="14 2 14 8 20 8"></polyline>
                                <line x1="16" y1="13" x2="8" y2="13"></line>
                                <line x1="16" y1="17" x2="8" y2="17"></line>
                                <polyline points="10 9 9 9 8 9"></polyline>
                            </svg>
                            Parse Message
                        </button>
                        <button class="btn-secondary" onclick="loadSample()">
                            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"></path>
                                <polyline points="14 2 14 8 20 8"></polyline>
                            </svg>
                            Load Sample
                        </button>
                        <button class="btn-secondary" onclick="clearAll()">
                            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <polyline points="3 6 5 6 21 6"></polyline>
                                <path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path>
                            </svg>
                            Clear
                        </button>
                    </div>
                </div>
            </div>

            <div class="panel results-panel">
                <div class="panel-header">
                    <span class="panel-title">Parsed Results</span>
                    <button class="btn-secondary" onclick="openResultsOverlay()" id="popOutBtn" style="display: none;" title="Open in full-screen overlay">
                        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <path d="M8 3H5a2 2 0 0 0-2 2v3m18 0V5a2 2 0 0 0-2-2h-3m0 18h3a2 2 0 0 0 2-2v-3M3 16v3a2 2 0 0 0 2 2h3"></path>
                        </svg>
                        Pop Out
                    </button>
                </div>
                <div class="panel-body">
                    <div id="resultsContent">
                        <div class="empty-state">
                            <div class="empty-state-icon">ðŸ“‹</div>
                            <h3>No Message Parsed</h3>
                            <p>Paste an HL7 message and click "Parse Message" to view segments and extract embedded documents.</p>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <div id="documentsSection" class="documents-section" style="display: none;">
            <div class="panel">
                <div class="panel-header">
                    <span class="panel-title">Extracted Documents</span>
                    <span class="doc-count" id="docCount">0</span>
                </div>
                <div class="panel-body">
                    <div class="document-grid" id="documentGrid"></div>
                </div>
            </div>
        </div>

        <footer>
            <div class="footer-content">
                <a href="https://github.com/flatmapit/hl7-view" target="_blank" rel="noopener noreferrer">View on GitHub</a>
                <a href="https://github.com/flatmapit/hl7-view/releases" target="_blank" rel="noopener noreferrer">Download to use this HTML page locally or offline</a>
                <span>Version <span id="version">1.0.15</span></span>
                <span>&copy; 2025 Chris Gentle <a href="https://flatmapit.com" target="_blank" rel="noopener noreferrer">flatmapit.com</a></span>
                <a href="https://github.com/flatmapit/hl7-view/blob/main/LICENSE?plain=1" target="_blank" rel="noopener noreferrer">MIT License</a>
            </div>
        </footer>
    </div>

    <div class="modal" id="imageModal">
        <div class="modal-content">
            <button class="modal-close" onclick="closeModal()">&times;</button>
            <div id="modalBody"></div>
        </div>
    </div>

    <div class="results-overlay" id="resultsOverlay">
        <div class="results-overlay-content" id="resultsOverlayContent"></div>
    </div>

    <div class="toast" id="toast"></div>

    <script>
        // Application version
        const APP_VERSION = '1.0.15';

        // Magic number patterns for base64 encoded files
        const MAGIC_NUMBERS = {
            jpeg: ['/9j/', 'FFD8FF'],
            jpg: ['/9j/', 'FFD8FF'],
            png: ['iVBORw0KGgo', '89504E47'],
            pdf: ['JVBERi', '25504446'],
            gif: ['R0lGOD', '47494638'],
            tiff: ['SUkqAA', '49492A00', '4D4D002A'],
            zip: ['UEsDBBQ', '504B0304'],
            xml: ['PD94bWw', '3C3F786D'],
            svg: ['PHN2Zy', 'PD94bWwg'],
            dicom: ['RE1JQw', '4449434D'],
            doc: ['0M8R4KG', 'D0CF11E0'],
            docx: ['UEsDBBQ', '504B0304'],
            mp3: ['SUQzB', '494433'],
            wav: ['UklGR', '52494646'],
            mp4: ['AAAAIG', '00000020', 'ftyp']
        };

        // HL7 field separator defaults
        const DEFAULT_FIELD_SEP = '|';
        const DEFAULT_COMPONENT_SEP = '^';
        const DEFAULT_SUBCOMPONENT_SEP = '&';
        const DEFAULT_REPETITION_SEP = '~';
        const DEFAULT_ESCAPE_CHAR = '\\';

        // HL7 field name mappings by segment type
        const HL7_FIELD_NAMES = {
            'MSH': ['Segment ID', 'Field Separator', 'Encoding Characters', 'Sending Application', 'Sending Facility', 'Receiving Application', 'Receiving Facility', 'Date/Time of Message', 'Security', 'Message Type', 'Message Control ID', 'Processing ID', 'Version ID', 'Sequence Number', 'Continuation Pointer', 'Accept Acknowledgment Type', 'Application Acknowledgment Type', 'Country Code', 'Character Set', 'Principal Language of Message', 'Alternate Character Set Handling Scheme', 'Message Profile Identifier'],
            'PID': ['Set ID', 'Patient ID', 'Patient Identifier List', 'Alternate Patient ID', 'Patient Name', 'Mother\'s Maiden Name', 'Date/Time of Birth', 'Administrative Sex', 'Patient Alias', 'Race', 'Patient Address', 'County Code', 'Phone Number - Home', 'Phone Number - Business', 'Primary Language', 'Marital Status', 'Religion', 'Patient Account Number', 'SSN Number - Patient', 'Driver\'s License Number', 'Mother\'s Identifier', 'Ethnic Group', 'Birth Place', 'Multiple Birth Indicator', 'Birth Order', 'Citizenship', 'Veterans Military Status', 'Nationality', 'Patient Death Date and Time', 'Patient Death Indicator', 'Identity Unknown Indicator', 'Identity Reliability Code', 'Last Update Date/Time', 'Last Update Facility', 'Species Code', 'Breed Code', 'Strain', 'Production Class Code', 'Tribal Citizenship'],
            'OBX': ['Set ID', 'Value Type', 'Observation Identifier', 'Observation Sub-ID', 'Observation Value', 'Units', 'References Range', 'Abnormal Flags', 'Probability', 'Nature of Abnormal Test', 'Observation Result Status', 'Date Last Obs Normal Values', 'User Defined Access Checks', 'Date/Time of the Observation', 'Producer\'s ID', 'Responsible Observer', 'Observation Method', 'Equipment Instance Identifier', 'Date/Time of the Analysis'],
            'OBR': ['Set ID', 'Placer Order Number', 'Filler Order Number', 'Universal Service Identifier', 'Priority', 'Requested Date/Time', 'Observation Date/Time', 'Observation End Date/Time', 'Collection Volume', 'Collector Identifier', 'Specimen Action Code', 'Danger Code', 'Relevant Clinical Information', 'Specimen Received Date/Time', 'Specimen Source', 'Ordering Provider', 'Order Callback Phone Number', 'Placer Field 1', 'Placer Field 2', 'Filler Field 1', 'Filler Field 2', 'Results Rpt/Status Chng - Date/Time', 'Charge to Practice', 'Diagnostic Serv Sect ID', 'Result Status', 'Parent Result', 'Quantity/Timing', 'Result Copies To', 'Parent', 'Transportation Mode', 'Reason for Study', 'Principal Result Interpreter', 'Assistant Result Interpreter', 'Technician', 'Transcriptionist', 'Scheduled Date/Time', 'Number of Sample Containers', 'Transport Logistics of Collected Sample', 'Collector\'s Comment', 'Transport Arrangement Responsibility', 'Transport Arranged', 'Escort Required', 'Planned Patient Transport Comment', 'Procedure Code', 'Procedure Code Modifier', 'Placer Supplemental Service Information', 'Filler Supplemental Service Information', 'Medically Necessary Duplicate Procedure Reason', 'Result Handling', 'Parent Universal Service Identifier'],
            'PV1': ['Set ID', 'Patient Class', 'Assigned Patient Location', 'Admission Type', 'Preadmit Number', 'Prior Patient Location', 'Attending Doctor', 'Referring Doctor', 'Consulting Doctor', 'Hospital Service', 'Temporary Location', 'Preadmit Test Indicator', 'Re-admission Indicator', 'Admit Source', 'Ambulatory Status', 'VIP Indicator', 'Admitting Doctor', 'Patient Type', 'Visit Number', 'Financial Class', 'Charge Price Indicator', 'Courtesy Code', 'Credit Rating', 'Contract Code', 'Contract Effective Date', 'Contract Amount', 'Contract Period', 'Interest Code', 'Transfer to Bad Debt Code', 'Transfer to Bad Debt Date', 'Bad Debt Agency Code', 'Bad Debt Transfer Amount', 'Bad Debt Recovery Amount', 'Delete Account Indicator', 'Delete Account Date', 'Discharge Disposition', 'Discharged to Location', 'Diet Type', 'Servicing Facility', 'Bed Status', 'Account Status', 'Pending Location', 'Prior Temporary Location', 'Admit Date/Time', 'Discharge Date/Time', 'Current Patient Balance', 'Total Charges', 'Total Adjustments', 'Total Payments', 'Alternate Visit ID', 'Visit Indicator', 'Other Healthcare Provider'],
            'ORC': ['Order Control', 'Placer Order Number', 'Filler Order Number', 'Placer Group Number', 'Order Status', 'Response Flag', 'Quantity/Timing', 'Parent', 'Date/Time of Transaction', 'Entered By', 'Verified By', 'Ordering Provider', 'Enterer\'s Location', 'Call Back Phone Number', 'Order Effective Date/Time', 'Order Control Code Reason', 'Entering Organization', 'Entering Device', 'Action By', 'Advanced Beneficiary Notice Code', 'Ordering Facility Name', 'Ordering Facility Address', 'Ordering Facility Phone Number', 'Ordering Provider Address', 'Order Status Modifier'],
            'NTE': ['Set ID', 'Source of Comment', 'Comment', 'Comment Type'],
            'AL1': ['Set ID', 'Allergen Type Code', 'Allergen Code/Mnemonic/Description', 'Allergy Severity Code', 'Allergy Reaction Code', 'Identification Date'],
            'DG1': ['Set ID', 'Diagnosis Coding Method', 'Diagnosis Code', 'Diagnosis Description', 'Diagnosis Date/Time', 'Diagnosis Type', 'Major Diagnostic Category', 'Diagnostic Related Group', 'DRG Approval Indicator', 'DRG Grouper Review Code', 'Outlier Type', 'Outlier Days', 'Outlier Cost', 'Grouper Version And Type', 'Diagnosis Priority', 'Diagnosing Clinician', 'Diagnosis Classification', 'Confidential Indicator', 'Attestation Date/Time', 'Diagnosis Identifier', 'Diagnosis Action Code'],
            'PR1': ['Set ID', 'Procedure Coding Method', 'Procedure Code', 'Procedure Description', 'Procedure Date/Time', 'Procedure Functional Type', 'Procedure Minutes', 'Anesthesiologist', 'Anesthesia Code', 'Anesthesia Minutes', 'Surgeon', 'Procedure Practitioner', 'Consent Code', 'Procedure Priority', 'Associated Diagnosis Code', 'Procedure Code Modifier', 'Procedure DRG Type', 'Tissue Type Code', 'Procedure Identifier', 'Procedure Action Code']
        };

        let parsedSegments = [];
        let extractedDocuments = [];
        let hl7Version = '2.5'; // Default to 2.5 if not specified
        let selectedFieldValue = null; // Currently selected field value for highlighting

        function parseHL7() {
            const input = document.getElementById('hl7Input').value.trim();
            if (!input) {
                showToast('Please enter an HL7 message', 'error');
                return;
            }

            // Clear any existing field highlights
            clearFieldHighlight();

            // Parse the message
            const lines = input.split(/\r\n|\r|\n/).filter(line => line.trim());
            parsedSegments = [];
            extractedDocuments = [];

            // Get encoding characters from MSH segment if present
            let fieldSep = DEFAULT_FIELD_SEP;
            let componentSep = DEFAULT_COMPONENT_SEP;

            const mshLine = lines.find(l => l.startsWith('MSH'));
            if (mshLine && mshLine.length > 3) {
                fieldSep = mshLine[3];
                if (mshLine.length > 4) {
                    componentSep = mshLine[4];
                }
            }

            // Extract HL7 version from MSH-12 (field index 12)
            hl7Version = '2.5'; // Default
            if (mshLine) {
                let mshFields;
                if (mshLine.length > 3) {
                    mshFields = ['MSH', fieldSep, ...mshLine.substring(4).split(fieldSep)];
                    if (mshFields.length > 12 && mshFields[12]) {
                        const versionField = mshFields[12].trim();
                        // Extract version number (e.g., "2.5", "2.3", "2.4")
                        const versionMatch = versionField.match(/(\d+\.\d+)/);
                        if (versionMatch) {
                            hl7Version = versionMatch[1];
                        }
                    }
                }
            }

            lines.forEach((line, index) => {
                const segmentType = line.substring(0, 3);
                let fields;

                if (segmentType === 'MSH') {
                    // MSH is special - field separator is at position 3
                    fields = ['MSH', fieldSep, ...line.substring(4).split(fieldSep)];
                } else {
                    fields = line.split(fieldSep);
                }

                const segment = {
                    index: index,
                    type: segmentType,
                    raw: line,
                    fields: fields
                };

                parsedSegments.push(segment);

                // Check OBX segments for embedded documents
                if (segmentType === 'OBX') {
                    const doc = extractDocument(segment, componentSep);
                    if (doc) {
                        extractedDocuments.push(doc);
                    }
                }
            });

            renderResults();
            renderDocuments();
        }

        function extractDocument(segment, componentSep) {
            const fields = segment.fields;

            // OBX-2 is Value Type (should be 'ED' for Encapsulated Data)
            const valueType = fields[2] || '';

            // OBX-3 is Observation Identifier
            const obsIdentifier = fields[3] || '';

            // OBX-4 is Observation Sub-ID (may contain hints)
            const subId = fields[4] || '';

            // OBX-5 is Observation Value (contains the data)
            const obsValue = fields[5] || '';

            // Parse the observation value components
            // Format: source^type^subtype^encoding^data
            const components = obsValue.split(componentSep);

            let dataType = null;
            let encoding = null;
            let base64Data = null;

            if (valueType === 'ED' || valueType === 'RP') {
                // Standard ED format
                if (components.length >= 5) {
                    const typeHint = (components[1] || '').toLowerCase();
                    const subtypeHint = (components[2] || '').toLowerCase();
                    encoding = (components[3] || '').toLowerCase();
                    base64Data = components[4] || '';

                    // Determine type from hints
                    if (subtypeHint.includes('pdf') || typeHint.includes('pdf')) {
                        dataType = 'pdf';
                    } else if (subtypeHint.includes('jpeg') || subtypeHint.includes('jpg') ||
                               typeHint.includes('jpeg') || typeHint.includes('jpg')) {
                        dataType = 'jpeg';
                    } else if (subtypeHint.includes('png') || typeHint.includes('png')) {
                        dataType = 'png';
                    } else if (subtypeHint.includes('gif') || typeHint.includes('gif')) {
                        dataType = 'gif';
                    } else if (subtypeHint.includes('tiff') || subtypeHint.includes('tif') ||
                               typeHint.includes('tiff') || typeHint.includes('tif')) {
                        dataType = 'tiff';
                    } else if (subtypeHint.includes('rtf') || typeHint.includes('rtf')) {
                        dataType = 'rtf';
                    } else if (subtypeHint.includes('html') || typeHint.includes('html') ||
                               subtypeHint.includes('htm') || typeHint.includes('htm')) {
                        dataType = 'html';
                    } else if (subtypeHint.includes('zip') || typeHint.includes('zip')) {
                        dataType = 'zip';
                    } else if (subtypeHint.includes('xml') || typeHint.includes('xml')) {
                        dataType = 'xml';
                    } else if (subtypeHint.includes('svg') || typeHint.includes('svg')) {
                        dataType = 'svg';
                    } else if (subtypeHint.includes('dicom') || typeHint.includes('dicom') ||
                               subtypeHint.includes('dcm') || typeHint.includes('dcm')) {
                        dataType = 'dicom';
                    } else if (subtypeHint.includes('msword') || typeHint.includes('msword') ||
                               subtypeHint.includes('word') || typeHint.includes('word') ||
                               subtypeHint.includes('doc') && !subtypeHint.includes('docx')) {
                        dataType = 'doc';
                    } else if (subtypeHint.includes('wordprocessingml') || 
                               subtypeHint.includes('docx') || typeHint.includes('docx')) {
                        dataType = 'docx';
                    } else if (subtypeHint.includes('mpeg') || subtypeHint.includes('mp3') ||
                               typeHint.includes('mpeg') || typeHint.includes('mp3')) {
                        dataType = 'mp3';
                    } else if (subtypeHint.includes('wav') || typeHint.includes('wav') ||
                               subtypeHint.includes('wave') || typeHint.includes('wave')) {
                        dataType = 'wav';
                    } else if (subtypeHint.includes('mp4') || typeHint.includes('mp4') ||
                               subtypeHint.includes('mpeg4') || typeHint.includes('mpeg4')) {
                        dataType = 'mp4';
                    } else if (subtypeHint.includes('hl7-scp-ecg') || typeHint.includes('hl7-scp-ecg') ||
                               subtypeHint.includes('ecg') || typeHint.includes('ecg')) {
                        dataType = 'hl7-scp-ecg';
                    }
                }
            }

            // If we have data but no type, try to detect from base64 data
            // Also check for raw base64 data in OBX-5
            if (!base64Data && obsValue) {
                // Maybe the data is directly in OBX-5 without ED structure
                base64Data = obsValue.replace(/[\s^|]/g, '');
            }

            if (base64Data && !dataType) {
                dataType = detectTypeFromMagic(base64Data);
            }

            // Also check OBX-3 and OBX-4 for type hints
            if (!dataType) {
                const hints = (obsIdentifier + ' ' + subId).toLowerCase();
                if (hints.includes('pdf')) dataType = 'pdf';
                else if (hints.includes('jpeg') || hints.includes('jpg')) dataType = 'jpeg';
                else if (hints.includes('png')) dataType = 'png';
                else if (hints.includes('gif')) dataType = 'gif';
                else if (hints.includes('tiff') || hints.includes('tif')) dataType = 'tiff';
                else if (hints.includes('rtf')) dataType = 'rtf';
                else if (hints.includes('html') || hints.includes('htm')) dataType = 'html';
                else if (hints.includes('zip')) dataType = 'zip';
                else if (hints.includes('xml')) dataType = 'xml';
                else if (hints.includes('svg')) dataType = 'svg';
                else if (hints.includes('dicom') || hints.includes('dcm')) dataType = 'dicom';
                else if (hints.includes('msword') || (hints.includes('doc') && !hints.includes('docx'))) dataType = 'doc';
                else if (hints.includes('wordprocessingml') || hints.includes('docx')) dataType = 'docx';
                else if (hints.includes('mpeg') || hints.includes('mp3')) dataType = 'mp3';
                else if (hints.includes('wav') || hints.includes('wave')) dataType = 'wav';
                else if (hints.includes('mp4') || hints.includes('mpeg4')) dataType = 'mp4';
                else if (hints.includes('hl7-scp-ecg') || hints.includes('ecg')) dataType = 'hl7-scp-ecg';
            }

            if (base64Data && dataType) {
                // Clean the base64 data
                base64Data = base64Data.replace(/[\s\r\n]/g, '');

                // Validate it looks like base64
                if (isValidBase64(base64Data)) {
                    const doc = {
                        segmentIndex: segment.index,
                        type: dataType,
                        encoding: encoding || 'base64',
                        data: base64Data,
                        obsIdentifier: obsIdentifier,
                        subId: subId,
                        size: Math.round((base64Data.length * 3) / 4 / 1024) // Approximate KB
                    };
                    
                    // Extract document properties (EXIF, metadata, etc.)
                    try {
                        const properties = extractDocumentProperties(base64Data, dataType);
                        if (Object.keys(properties).length > 0) {
                            doc.properties = properties;
                        }
                    } catch (e) {
                        // Error extracting properties, continue without them
                    }
                    
                    return doc;
                }
            }

            return null;
        }

        function detectTypeFromMagic(base64Data) {
            // Check first few characters of base64 for magic numbers
            const prefix = base64Data.substring(0, 20);

            for (const [type, patterns] of Object.entries(MAGIC_NUMBERS)) {
                for (const pattern of patterns) {
                    if (prefix.startsWith(pattern)) {
                        return type;
                    }
                }
            }

            // Try decoding first few bytes
            try {
                const decoded = atob(base64Data.substring(0, 20));
                const bytes = new Uint8Array(decoded.length);
                for (let i = 0; i < decoded.length; i++) {
                    bytes[i] = decoded.charCodeAt(i);
                }

                // Check magic bytes
                if (bytes[0] === 0xFF && bytes[1] === 0xD8 && bytes[2] === 0xFF) {
                    return 'jpeg';
                }
                if (bytes[0] === 0x89 && bytes[1] === 0x50 && bytes[2] === 0x4E && bytes[3] === 0x47) {
                    return 'png';
                }
                if (bytes[0] === 0x25 && bytes[1] === 0x50 && bytes[2] === 0x44 && bytes[3] === 0x46) {
                    return 'pdf';
                }
                if (bytes[0] === 0x47 && bytes[1] === 0x49 && bytes[2] === 0x46 && bytes[3] === 0x38) {
                    return 'gif';
                }
                if ((bytes[0] === 0x49 && bytes[1] === 0x49 && bytes[2] === 0x2A && bytes[3] === 0x00) ||
                    (bytes[0] === 0x4D && bytes[1] === 0x4D && bytes[2] === 0x00 && bytes[3] === 0x2A)) {
                    return 'tiff';
                }
                if (bytes[0] === 0x50 && bytes[1] === 0x4B && bytes[2] === 0x03 && bytes[3] === 0x04) {
                    // Could be ZIP, DOCX, or other Office formats
                    // Check further to distinguish
                    if (decoded.length > 30) {
                        const moreDecoded = atob(base64Data.substring(0, 100));
                        if (moreDecoded.includes('word/') || moreDecoded.includes('WordDocument')) {
                            return 'docx';
                        }
                    }
                    return 'zip';
                }
                if (bytes[0] === 0xD0 && bytes[1] === 0xCF && bytes[2] === 0x11 && bytes[3] === 0xE0) {
                    return 'doc';
                }
                if (bytes[0] === 0x52 && bytes[1] === 0x49 && bytes[2] === 0x46 && bytes[3] === 0x46) {
                    // RIFF - could be WAV or other formats
                    if (decoded.length > 8) {
                        const moreDecoded = atob(base64Data.substring(0, 20));
                        if (moreDecoded.includes('WAVE')) {
                            return 'wav';
                        }
                    }
                }
                if (bytes[0] === 0x49 && bytes[1] === 0x44 && bytes[2] === 0x33) {
                    return 'mp3';
                }
                // Check for XML/SVG (starts with < or <?xml)
                if (bytes[0] === 0x3C) {
                    const decodedStr = atob(base64Data.substring(0, 50));
                    if (decodedStr.includes('<svg') || decodedStr.includes('xmlns="http://www.w3.org/2000/svg"')) {
                        return 'svg';
                    }
                    if (decodedStr.includes('<?xml') || decodedStr.includes('<xml')) {
                        return 'xml';
                    }
                    if (decodedStr.includes('<html') || decodedStr.includes('<!DOCTYPE html')) {
                        return 'html';
                    }
                }
                // Check for DICOM (starts with DICM at offset 128)
                if (decoded.length > 132) {
                    const dicomCheck = atob(base64Data.substring(0, 150));
                    if (dicomCheck.substring(128, 132) === 'DICM') {
                        return 'dicom';
                    }
                }
            } catch (e) {
                // Invalid base64
            }

            return null;
        }

        function isValidBase64(str) {
            if (!str || str.length < 4) return false;
            try {
                // Check if it's valid base64 format
                return /^[A-Za-z0-9+/]*={0,2}$/.test(str);
            } catch (e) {
                return false;
            }
        }

        function extractDocumentProperties(base64Data, docType) {
            try {
                const properties = {};
                
                if (docType === 'jpeg' || docType === 'jpg') {
                    return extractJPEGExif(base64Data);
                } else if (docType === 'pdf') {
                    return extractPDFProperties(base64Data);
                } else if (docType === 'mp3') {
                    return extractMP3Properties(base64Data);
                } else if (docType === 'png') {
                    return extractPNGProperties(base64Data);
                } else if (docType === 'tiff' || docType === 'tif') {
                    return extractTIFFProperties(base64Data);
                }
                
                return properties;
            } catch (e) {
                return {};
            }
        }

        function extractJPEGExif(base64Data) {
            const properties = {};
            try {
                const binary = atob(base64Data);
                const bytes = new Uint8Array(binary.length);
                for (let i = 0; i < binary.length; i++) {
                    bytes[i] = binary.charCodeAt(i);
                }

                // JPEG starts with FF D8 FF
                if (bytes[0] !== 0xFF || bytes[1] !== 0xD8 || bytes[2] !== 0xFF) {
                    return properties;
                }

                let offset = 2;
                while (offset < bytes.length - 1) {
                    if (bytes[offset] !== 0xFF) break;
                    const marker = bytes[offset + 1];
                    
                    // APP1 marker (0xE1) contains EXIF
                    if (marker === 0xE1) {
                        const exifLength = (bytes[offset + 2] << 8) | bytes[offset + 3];
                        const exifData = bytes.slice(offset + 4, offset + 4 + exifLength - 2);
                        
                        // Check for EXIF header "Exif\0\0"
                        if (exifData[0] === 0x45 && exifData[1] === 0x78 && 
                            exifData[2] === 0x69 && exifData[3] === 0x66) {
                            const exifProps = parseExifData(exifData);
                            Object.assign(properties, exifProps);
                        }
                    }
                    
                    // APP0 marker (0xE0) - JFIF
                    if (marker === 0xE0) {
                        const jfifLength = (bytes[offset + 2] << 8) | bytes[offset + 3];
                        if (jfifLength > 5) {
                            const identifier = String.fromCharCode(
                                bytes[offset + 4], bytes[offset + 5], bytes[offset + 6],
                                bytes[offset + 7], bytes[offset + 8]
                            );
                            if (identifier === 'JFIF\0') {
                                if (!properties['Format']) properties['Format'] = 'JFIF';
                            }
                        }
                    }
                    
                    if (marker === 0xDA) break; // Start of scan
                    
                    const segmentLength = (bytes[offset + 2] << 8) | bytes[offset + 3];
                    offset += 2 + segmentLength;
                }
            } catch (e) {
                // Error parsing EXIF
            }
            return properties;
        }

        function parseExifData(exifData) {
            const props = {};
            try {
                // Simplified EXIF parsing - look for common tags
                // This is a basic implementation that extracts some common values
                const dataView = new DataView(exifData.buffer || new ArrayBuffer(exifData.length));
                let pos = 6; // Skip "Exif\0\0"
                
                // Check byte order (0x4949 = Intel, 0x4D4D = Motorola)
                const byteOrder = dataView.getUint16(pos, true);
                pos += 2;
                
                // Check TIFF header (should be 0x002A)
                const tiffHeader = byteOrder === 0x4949 
                    ? dataView.getUint16(pos, true)
                    : dataView.getUint16(pos, false);
                pos += 2;
                
                if (tiffHeader !== 0x002A) return props;
                
                // Get IFD offset
                const ifdOffset = byteOrder === 0x4949
                    ? dataView.getUint32(pos, true)
                    : dataView.getUint32(pos, false);
                pos = ifdOffset + 6;
                
                // Get number of entries
                const numEntries = byteOrder === 0x4949
                    ? dataView.getUint16(pos, true)
                    : dataView.getUint16(pos, false);
                pos += 2;
                
                // Common EXIF tag IDs
                const tags = {
                    0x010E: 'ImageDescription',
                    0x010F: 'Make',
                    0x0110: 'Model',
                    0x0132: 'DateTime',
                    0x011A: 'XResolution',
                    0x011B: 'YResolution',
                    0x0128: 'ResolutionUnit',
                    0x0131: 'Software',
                    0x013E: 'WhitePoint',
                    0x0213: 'YCbCrPositioning',
                    0x8298: 'Copyright',
                    0x8769: 'ExifIFD',
                    0x8825: 'GPSIFD'
                };
                
                for (let i = 0; i < Math.min(numEntries, 20); i++) {
                    const tagId = byteOrder === 0x4949
                        ? dataView.getUint16(pos, true)
                        : dataView.getUint16(pos, false);
                    pos += 2;
                    
                    const tagName = tags[tagId];
                    if (tagName && tagName !== 'ExifIFD' && tagName !== 'GPSIFD') {
                        const type = byteOrder === 0x4949
                            ? dataView.getUint16(pos, true)
                            : dataView.getUint16(pos, false);
                        pos += 2;
                        
                        const count = byteOrder === 0x4949
                            ? dataView.getUint32(pos, true)
                            : dataView.getUint32(pos, false);
                        pos += 4;
                        
                        let value = '';
                        if (type === 2 && count > 0 && count < 100) { // ASCII string
                            const valueOffset = byteOrder === 0x4949
                                ? dataView.getUint32(pos, true)
                                : dataView.getUint32(pos, false);
                            const strPos = valueOffset + 6;
                            if (strPos < exifData.length) {
                                for (let j = 0; j < count - 1 && strPos + j < exifData.length; j++) {
                                    const char = exifData[strPos + j];
                                    if (char >= 32 && char < 127) {
                                        value += String.fromCharCode(char);
                                    }
                                }
                                if (value) {
                                    props[tagName] = value.trim();
                                }
                            }
                        }
                        pos += 4;
                    } else {
                        pos += 10; // Skip this entry
                    }
                }
            } catch (e) {
                // Error parsing
            }
            return props;
        }

        function extractPDFProperties(base64Data) {
            const properties = {};
            try {
                // Decode the entire PDF file (or up to 1MB to avoid memory issues)
                const searchLimit = Math.min(base64Data.length, Math.floor(1000000 * 4 / 3));
                const binary = atob(base64Data.substring(0, searchLimit));
                
                // Check PDF version (usually at the start)
                const versionMatch = binary.match(/%PDF-(\d\.\d)/);
                if (versionMatch) {
                    properties['PDFVersion'] = versionMatch[1];
                }
                
                // Check if encrypted
                if (binary.includes('/Encrypt')) {
                    properties['Encrypted'] = 'Yes';
                }
                
                // Function to extract all key-value pairs from a dictionary string
                function extractAllPropertiesFromDict(dictContent) {
                    const foundProps = {};
                    
                    // Match all property patterns: /KeyName (value) or /KeyName <hexvalue>
                    // This regex finds all /KeyName followed by either (value) or <hexvalue>
                    const propPattern = /\/([A-Za-z][A-Za-z0-9]*)\s*(?:\(([^)]*)\)|<([0-9A-Fa-f\s]+)>)/g;
                    let match;
                    
                    while ((match = propPattern.exec(dictContent)) !== null) {
                        const propName = match[1];
                        let propValue = '';
                        
                        if (match[2] !== undefined) {
                            // Literal string value
                            propValue = decodePDFString(match[2]);
                        } else if (match[3] !== undefined) {
                            // Hex string value
                            propValue = decodePDFHexString(match[3]);
                        }
                        
                        if (propValue && propValue.trim() && !foundProps[propName]) {
                            foundProps[propName] = propValue.trim();
                        }
                    }
                    
                    return foundProps;
                }
                
                // Find Info dictionary - try multiple approaches
                let infoDictContent = '';
                
                // Approach 1: Direct Info dictionary in trailer
                const directInfoMatch = binary.match(/\/Info\s*<<([^>]*)>>/s);
                if (directInfoMatch) {
                    infoDictContent = directInfoMatch[1];
                }
                
                // Approach 2: Info as indirect object reference
                if (!infoDictContent) {
                    const infoRefMatch = binary.match(/\/Info\s+(\d+)\s+(\d+)\s+R/);
                    if (infoRefMatch) {
                        const objNum = infoRefMatch[1];
                        const genNum = infoRefMatch[2];
                        // Look for the object definition - handle multiline
                        const objPattern = new RegExp(`${objNum}\\s+${genNum}\\s+obj[\\s\\S]*?<<([^>]*)>>`, 's');
                        const objMatch = binary.match(objPattern);
                        if (objMatch) {
                            infoDictContent = objMatch[1];
                        }
                    }
                }
                
                // Approach 3: Look for any object that might be the Info dictionary
                if (!infoDictContent) {
                    // Search for objects that contain common Info dictionary keys
                    const infoObjPattern = /(\d+)\s+(\d+)\s+obj\s*<<([^>]*)>>/gs;
                    let objMatch;
                    while ((objMatch = infoObjPattern.exec(binary)) !== null) {
                        const objContent = objMatch[3];
                        // Check if this looks like an Info dictionary (has common keys)
                        if (objContent.includes('/Title') || objContent.includes('/Author') || 
                            objContent.includes('/Subject') || objContent.includes('/Creator')) {
                            infoDictContent = objContent;
                            break;
                        }
                    }
                }
                
                // Extract ALL properties from Info dictionary (including custom ones)
                if (infoDictContent) {
                    const dictProps = extractAllPropertiesFromDict(infoDictContent);
                    Object.assign(properties, dictProps);
                }
                
                // Also search the entire binary for any property patterns (fallback for custom properties)
                // This catches properties that might be outside the Info dictionary
                const globalPropPattern = /\/([A-Za-z][A-Za-z0-9]*)\s*(?:\(([^)]*)\)|<([0-9A-Fa-f\s]+)>)/g;
                let globalMatch;
                const foundGlobalProps = {};
                let matchCount = 0;
                
                // Limit to first 100 matches to avoid performance issues
                while ((globalMatch = globalPropPattern.exec(binary)) !== null && matchCount < 100) {
                    const propName = globalMatch[1];
                    // Skip if we already have this property
                    if (properties[propName] || foundGlobalProps[propName]) {
                        continue;
                    }
                    
                    let propValue = '';
                    if (globalMatch[2] !== undefined) {
                        propValue = decodePDFString(globalMatch[2]);
                    } else if (globalMatch[3] !== undefined) {
                        propValue = decodePDFHexString(globalMatch[3]);
                    }
                    
                    // Only add if it looks like a meaningful property (not PDF internals)
                    if (propValue && propValue.trim() && 
                        !propName.match(/^(Type|Subtype|Filter|Length|Width|Height|Bits|ColorSpace|Font|Resources|MediaBox|Page|Parent|Kids|Contents|Rotate|Annots|XObject|ExtGState|ProcSet)$/i)) {
                        foundGlobalProps[propName] = propValue.trim();
                    }
                    matchCount++;
                }
                
                // Add global properties that aren't already in properties
                for (const [key, value] of Object.entries(foundGlobalProps)) {
                    if (!properties[key]) {
                        properties[key] = value;
                    }
                }
                
                // Look for XMP metadata (XML-based metadata) - extract more properties
                const xmpMatch = binary.match(/<x:xmpmeta[^>]*>([\s\S]*?)<\/x:xmpmeta>/i);
                if (xmpMatch) {
                    const xmpContent = xmpMatch[1];
                    
                    // Extract XMP properties more comprehensively
                    const xmpProps = {
                        'Title': /<dc:title[^>]*>[\s\S]*?<rdf:li[^>]*>([^<]+)<\/rdf:li>/i,
                        'Author': /<dc:creator[^>]*>[\s\S]*?<rdf:li[^>]*>([^<]+)<\/rdf:li>/i,
                        'Subject': /<dc:description[^>]*>[\s\S]*?<rdf:li[^>]*>([^<]+)<\/rdf:li>/i,
                        'Keywords': /<pdf:Keywords>([^<]+)<\/pdf:Keywords>/i,
                        'Creator': /<xmp:CreatorTool>([^<]+)<\/xmp:CreatorTool>/i,
                        'Producer': /<pdf:Producer>([^<]+)<\/pdf:Producer>/i,
                        'CreationDate': /<xmp:CreateDate>([^<]+)<\/xmp:CreateDate>/i,
                        'ModDate': /<xmp:ModifyDate>([^<]+)<\/xmp:ModifyDate>/i
                    };
                    
                    for (const [propName, pattern] of Object.entries(xmpProps)) {
                        const match = xmpContent.match(pattern);
                        if (match && match[1] && !properties[propName]) {
                            properties[propName] = match[1].trim();
                        }
                    }
                    
                    // Extract custom XMP properties (any rdf:Description attributes or custom namespaces)
                    const customXmpPattern = /<rdf:Description[^>]*([^>]*)>/gi;
                    let xmpDescMatch;
                    while ((xmpDescMatch = customXmpPattern.exec(xmpContent)) !== null) {
                        const attrs = xmpDescMatch[1];
                        // Extract namespace:property="value" patterns
                        const attrPattern = /([a-z]+):([a-z]+)="([^"]+)"/gi;
                        let attrMatch;
                        while ((attrMatch = attrPattern.exec(attrs)) !== null) {
                            const ns = attrMatch[1];
                            const prop = attrMatch[2];
                            const value = attrMatch[3];
                            const fullName = `${ns}:${prop}`;
                            if (value && value.trim() && !properties[fullName]) {
                                properties[fullName] = value.trim();
                            }
                        }
                    }
                }
                
            } catch (e) {
                // Error parsing PDF
            }
            return properties;
        }
        
        function decodePDFHexString(hexStr) {
            try {
                // Remove whitespace and decode hex pairs
                const cleanHex = hexStr.replace(/\s/g, '');
                let result = '';
                for (let i = 0; i < cleanHex.length; i += 2) {
                    const hexByte = cleanHex.substr(i, 2);
                    const charCode = parseInt(hexByte, 16);
                    if (charCode >= 32 && charCode < 127) {
                        result += String.fromCharCode(charCode);
                    } else if (charCode === 0) {
                        // Null terminator, stop
                        break;
                    }
                }
                return result;
            } catch (e) {
                return '';
            }
        }

        function decodePDFString(str) {
            try {
                // Basic PDF string decoding (handles escape sequences)
                return str.replace(/\\([0-7]{1,3})/g, (match, octal) => {
                    return String.fromCharCode(parseInt(octal, 8));
                }).replace(/\\n/g, '\n').replace(/\\r/g, '\r').replace(/\\t/g, '\t');
            } catch (e) {
                return str;
            }
        }

        function extractMP3Properties(base64Data) {
            const properties = {};
            try {
                const binary = atob(base64Data);
                const bytes = new Uint8Array(binary.length);
                for (let i = 0; i < binary.length; i++) {
                    bytes[i] = binary.charCodeAt(i);
                }

                // Check for ID3v2 tag (starts with "ID3")
                if (bytes.length >= 10 && 
                    bytes[0] === 0x49 && bytes[1] === 0x44 && bytes[2] === 0x33) {
                    const version = bytes[3];
                    const revision = bytes[4];
                    const flags = bytes[5];
                    const size = (bytes[6] << 21) | (bytes[7] << 14) | (bytes[8] << 7) | bytes[9];
                    
                    properties['ID3Version'] = `2.${version}.${revision}`;
                    
                    let pos = 10;
                    const endPos = Math.min(pos + size, bytes.length);
                    
                    while (pos < endPos - 10) {
                        const frameId = String.fromCharCode(
                            bytes[pos], bytes[pos + 1], bytes[pos + 2], bytes[pos + 3]
                        );
                        pos += 4;
                        
                        if (frameId === '\0\0\0\0') break;
                        
                        const frameSize = version >= 3
                            ? (bytes[pos] << 24) | (bytes[pos + 1] << 16) | 
                              (bytes[pos + 2] << 8) | bytes[pos + 3]
                            : (bytes[pos] << 21) | (bytes[pos + 1] << 14) | 
                              (bytes[pos + 2] << 7) | bytes[pos + 3];
                        pos += 4;
                        
                        if (version >= 3) {
                            pos += 2; // Skip flags
                        }
                        
                        const frameData = bytes.slice(pos, pos + frameSize);
                        pos += frameSize;
                        
                        // Common ID3v2 frame IDs
                        if (frameId === 'TIT2' || frameId === 'TT2') {
                            properties['Title'] = decodeID3Text(frameData);
                        } else if (frameId === 'TPE1' || frameId === 'TP1') {
                            properties['Artist'] = decodeID3Text(frameData);
                        } else if (frameId === 'TALB' || frameId === 'TAL') {
                            properties['Album'] = decodeID3Text(frameData);
                        } else if (frameId === 'TYER' || frameId === 'TYE' || frameId === 'TDRC') {
                            properties['Year'] = decodeID3Text(frameData);
                        } else if (frameId === 'TCON' || frameId === 'TCO') {
                            properties['Genre'] = decodeID3Text(frameData);
                        } else if (frameId === 'TRCK' || frameId === 'TRK') {
                            properties['Track'] = decodeID3Text(frameData);
                        } else if (frameId === 'TPE2' || frameId === 'TP2') {
                            properties['AlbumArtist'] = decodeID3Text(frameData);
                        } else if (frameId === 'TCOM' || frameId === 'TCM') {
                            properties['Composer'] = decodeID3Text(frameData);
                        }
                    }
                }
                
                // Check for ID3v1 tag at the end
                if (bytes.length >= 128) {
                    const id3v1Start = bytes.length - 128;
                    if (bytes[id3v1Start] === 0x54 && bytes[id3v1Start + 1] === 0x41 && 
                        bytes[id3v1Start + 2] === 0x47) {
                        if (!properties['Title']) {
                            properties['Title'] = decodeID3v1String(bytes, id3v1Start + 3, 30);
                        }
                        if (!properties['Artist']) {
                            properties['Artist'] = decodeID3v1String(bytes, id3v1Start + 33, 30);
                        }
                        if (!properties['Album']) {
                            properties['Album'] = decodeID3v1String(bytes, id3v1Start + 63, 30);
                        }
                        if (!properties['Year']) {
                            properties['Year'] = decodeID3v1String(bytes, id3v1Start + 93, 4);
                        }
                        if (!properties['Genre']) {
                            const genreId = bytes[id3v1Start + 127];
                            if (genreId < 192) {
                                properties['Genre'] = `ID3v1 Genre ${genreId}`;
                            }
                        }
                    }
                }
            } catch (e) {
                // Error parsing MP3
            }
            return properties;
        }

        function decodeID3Text(data) {
            if (data.length === 0) return '';
            const encoding = data[0];
            const textData = data.slice(1);
            let text = '';
            
            if (encoding === 0 || encoding === 3) {
                // ISO-8859-1 or UTF-8
                for (let i = 0; i < textData.length; i++) {
                    if (textData[i] === 0) break;
                    text += String.fromCharCode(textData[i]);
                }
            } else if (encoding === 1 || encoding === 2) {
                // UTF-16 with BOM or UTF-16BE
                try {
                    const decoder = new TextDecoder(encoding === 1 ? 'utf-16' : 'utf-16be');
                    text = decoder.decode(textData.slice(0, textData.indexOf(0) >= 0 ? textData.indexOf(0) : textData.length));
                } catch (e) {
                    // Fallback
                    for (let i = 0; i < textData.length - 1; i += 2) {
                        if (textData[i] === 0 && textData[i + 1] === 0) break;
                        text += String.fromCharCode((textData[i] << 8) | textData[i + 1]);
                    }
                }
            }
            
            return text.trim();
        }

        function decodeID3v1String(bytes, start, length) {
            let str = '';
            for (let i = 0; i < length; i++) {
                const byte = bytes[start + i];
                if (byte === 0) break;
                str += String.fromCharCode(byte);
            }
            return str.trim();
        }

        function extractPNGProperties(base64Data) {
            const properties = {};
            try {
                const binary = atob(base64Data);
                const bytes = new Uint8Array(binary.length);
                for (let i = 0; i < binary.length; i++) {
                    bytes[i] = binary.charCodeAt(i);
                }

                // PNG starts with 89 50 4E 47 0D 0A 1A 0A
                if (bytes[0] !== 0x89 || bytes[1] !== 0x50 || bytes[2] !== 0x4E || bytes[3] !== 0x47) {
                    return properties;
                }

                let pos = 8; // Skip PNG signature
                
                while (pos < bytes.length - 8) {
                    const chunkLength = (bytes[pos] << 24) | (bytes[pos + 1] << 16) | 
                                       (bytes[pos + 2] << 8) | bytes[pos + 3];
                    pos += 4;
                    
                    const chunkType = String.fromCharCode(
                        bytes[pos], bytes[pos + 1], bytes[pos + 2], bytes[pos + 3]
                    );
                    pos += 4;
                    
                    if (chunkType === 'IHDR') {
                        const width = (bytes[pos] << 24) | (bytes[pos + 1] << 16) | 
                                     (bytes[pos + 2] << 8) | bytes[pos + 3];
                        const height = (bytes[pos + 4] << 24) | (bytes[pos + 5] << 16) | 
                                      (bytes[pos + 6] << 8) | bytes[pos + 7];
                        const bitDepth = bytes[pos + 8];
                        const colorType = bytes[pos + 9];
                        const compression = bytes[pos + 10];
                        const filter = bytes[pos + 11];
                        const interlace = bytes[pos + 12];
                        
                        properties['Width'] = width;
                        properties['Height'] = height;
                        properties['BitDepth'] = bitDepth;
                        properties['ColorType'] = colorType;
                    } else if (chunkType === 'tEXt' || chunkType === 'iTXt' || chunkType === 'zTXt') {
                        // Text chunk - extract keyword and text
                        let keywordEnd = pos;
                        while (keywordEnd < pos + chunkLength && bytes[keywordEnd] !== 0) {
                            keywordEnd++;
                        }
                        const keyword = String.fromCharCode.apply(null, 
                            Array.from(bytes.slice(pos, keywordEnd)));
                        const textStart = keywordEnd + (chunkType === 'zTXt' ? 2 : 
                                                       chunkType === 'iTXt' ? 5 : 1);
                        const text = String.fromCharCode.apply(null, 
                            Array.from(bytes.slice(textStart, pos + chunkLength)));
                        
                        if (keyword && text) {
                            properties[keyword] = text;
                        }
                    }
                    
                    pos += chunkLength + 4; // Skip chunk data and CRC
                    
                    if (chunkType === 'IEND') break;
                }
            } catch (e) {
                // Error parsing PNG
            }
            return properties;
        }

        function extractTIFFProperties(base64Data) {
            const properties = {};
            try {
                const binary = atob(base64Data);
                const bytes = new Uint8Array(binary.length);
                for (let i = 0; i < binary.length; i++) {
                    bytes[i] = binary.charCodeAt(i);
                }

                // TIFF starts with II (Intel) or MM (Motorola) followed by 0x002A
                if (bytes.length < 8) return properties;
                
                const byteOrder = bytes[0] === 0x49 && bytes[1] === 0x49 ? 'little' : 'big';
                const tiffHeader = byteOrder === 'little'
                    ? (bytes[2] | (bytes[3] << 8))
                    : ((bytes[2] << 8) | bytes[3]);
                
                if (tiffHeader !== 0x002A) return properties;
                
                const ifdOffset = byteOrder === 'little'
                    ? (bytes[4] | (bytes[5] << 8) | (bytes[6] << 16) | (bytes[7] << 24))
                    : ((bytes[4] << 24) | (bytes[5] << 16) | (bytes[6] << 8) | bytes[7]);
                
                if (ifdOffset >= bytes.length) return properties;
                
                let pos = ifdOffset;
                const numEntries = byteOrder === 'little'
                    ? (bytes[pos] | (bytes[pos + 1] << 8))
                    : ((bytes[pos] << 8) | bytes[pos + 1]);
                pos += 2;
                
                // Common TIFF tags
                const tags = {
                    0x0100: 'ImageWidth',
                    0x0101: 'ImageLength',
                    0x0102: 'BitsPerSample',
                    0x0103: 'Compression',
                    0x0106: 'PhotometricInterpretation',
                    0x0111: 'StripOffsets',
                    0x0115: 'SamplesPerPixel',
                    0x0116: 'RowsPerStrip',
                    0x0117: 'StripByteCounts',
                    0x011A: 'XResolution',
                    0x011B: 'YResolution',
                    0x011C: 'PlanarConfiguration',
                    0x0128: 'ResolutionUnit',
                    0x0131: 'Software',
                    0x0132: 'DateTime',
                    0x013E: 'WhitePoint',
                    0x013F: 'PrimaryChromaticities',
                    0x0211: 'YCbCrCoefficients',
                    0x0213: 'YCbCrPositioning',
                    0x0214: 'ReferenceBlackWhite',
                    0x8298: 'Copyright'
                };
                
                for (let i = 0; i < Math.min(numEntries, 30); i++) {
                    const tagId = byteOrder === 'little'
                        ? (bytes[pos] | (bytes[pos + 1] << 8))
                        : ((bytes[pos] << 8) | bytes[pos + 1]);
                    pos += 2;
                    
                    const tagName = tags[tagId];
                    if (tagName) {
                        const type = byteOrder === 'little'
                            ? (bytes[pos] | (bytes[pos + 1] << 8))
                            : ((bytes[pos] << 8) | bytes[pos + 1]);
                        pos += 2;
                        
                        const count = byteOrder === 'little'
                            ? (bytes[pos] | (bytes[pos + 1] << 8) | (bytes[pos + 2] << 16) | (bytes[pos + 3] << 24))
                            : ((bytes[pos] << 24) | (bytes[pos + 1] << 16) | (bytes[pos + 2] << 8) | bytes[pos + 3]);
                        pos += 4;
                        
                        if (type === 2 && count > 0 && count < 100) { // ASCII
                            const valueOffset = byteOrder === 'little'
                                ? (bytes[pos] | (bytes[pos + 1] << 8) | (bytes[pos + 2] << 16) | (bytes[pos + 3] << 24))
                                : ((bytes[pos] << 24) | (bytes[pos + 1] << 16) | (bytes[pos + 2] << 8) | bytes[pos + 3]);
                            
                            if (valueOffset < bytes.length) {
                                let value = '';
                                for (let j = 0; j < count - 1 && valueOffset + j < bytes.length; j++) {
                                    const char = bytes[valueOffset + j];
                                    if (char >= 32 && char < 127) {
                                        value += String.fromCharCode(char);
                                    }
                                }
                                if (value) {
                                    properties[tagName] = value.trim();
                                }
                            }
                        } else if (type === 3 && count === 1) { // SHORT
                            const value = byteOrder === 'little'
                                ? (bytes[pos] | (bytes[pos + 1] << 8))
                                : ((bytes[pos] << 8) | bytes[pos + 1]);
                            properties[tagName] = value;
                        } else if (type === 4 && count === 1) { // LONG
                            const value = byteOrder === 'little'
                                ? (bytes[pos] | (bytes[pos + 1] << 8) | (bytes[pos + 2] << 16) | (bytes[pos + 3] << 24))
                                : ((bytes[pos] << 24) | (bytes[pos + 1] << 16) | (bytes[pos + 2] << 8) | bytes[pos + 3]);
                            properties[tagName] = value;
                        }
                    }
                    pos += 4;
                }
            } catch (e) {
                // Error parsing TIFF
            }
            return properties;
        }

        function renderResults() {
            const container = document.getElementById('resultsContent');

            if (parsedSegments.length === 0) {
                container.innerHTML = `
                    <div class="empty-state">
                        <div class="empty-state-icon">âš ï¸</div>
                        <h3>No Segments Found</h3>
                        <p>The input doesn't appear to contain valid HL7 segments.</p>
                    </div>
                `;
                return;
            }

            const obxCount = parsedSegments.filter(s => s.type === 'OBX').length;
            const docCount = extractedDocuments.length;

            container.innerHTML = `
                <div class="stats-bar">
                    <div class="stat-item">
                        <div class="stat-value">${parsedSegments.length}</div>
                        <div class="stat-label">Segments</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value">${obxCount}</div>
                        <div class="stat-label">OBX Segments</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value">${docCount}</div>
                        <div class="stat-label">Documents Found</div>
                    </div>
                </div>
                <div class="segment-list" id="segmentList">
                    ${parsedSegments.map((seg, i) => `
                        <div class="segment-item ${seg.type === 'OBX' ? 'obx-segment' : ''}"
                             onclick="showSegmentDetail(${i})"
                             data-index="${i}">
                            <span class="segment-tag">${seg.type}</span>
                            <span>${truncate(seg.raw, 80)}</span>
                        </div>
                    `).join('')}
                </div>
                <div class="segment-detail" id="segmentDetail" style="display: none;"></div>
            `;
            
            // Show pop-out button when results are available
            const popOutBtn = document.getElementById('popOutBtn');
            if (popOutBtn) {
                popOutBtn.style.display = 'inline-flex';
            }
        }

        function getFieldName(segmentType, hl7FieldNumber) {
            const fieldNames = HL7_FIELD_NAMES[segmentType];
            // HL7 field numbers match array indices (fields[1] = field-1, fields[5] = field-5)
            // But field name arrays are 0-indexed, so field-1 is at index 0, field-5 is at index 4
            // For MSH: fields[0]='MSH', fields[1]=MSH-1, fields[2]=MSH-2, etc.
            // For other segments: fields[0]=segment type, fields[1]=field-1, fields[2]=field-2, etc.
            // So hl7FieldNumber 1 maps to array index 0, hl7FieldNumber 5 maps to array index 4
            const arrayIndex = hl7FieldNumber - 1;
            if (fieldNames && arrayIndex >= 0 && fieldNames[arrayIndex]) {
                return fieldNames[arrayIndex];
            }
            return null;
        }

        function showSegmentDetail(index) {
            const segment = parsedSegments[index];
            const detailDiv = document.getElementById('segmentDetail');

            // Update active state
            document.querySelectorAll('.segment-item').forEach(el => el.classList.remove('active'));
            document.querySelector(`.segment-item[data-index="${index}"]`).classList.add('active');

            // Create segment header with copy icon
            const segmentHeader = `
                <div class="segment-header">
                    <div class="segment-type-header">
                        <span class="field-highlight">${escapeHtml(segment.type)}</span>
                        <span style="color: var(--text-secondary); font-size: 0.75rem; margin-left: 0.5rem;">HL7 v${hl7Version}</span>
                        <span class="copy-icon" onclick="copySegmentToClipboard(${index}, event)" title="Copy segment to clipboard">
                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                <rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect>
                                <path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path>
                            </svg>
                        </span>
                    </div>
                </div>
            `;

            // Format all fields with copy icons
            const fieldLength = 150; // Characters before ellipsis
            const fieldsHtml = segment.fields.map((field, i) => {
                const fieldValue = field || '';
                const isLong = fieldValue.length > fieldLength;
                const fullField = escapeHtml(fieldValue);
                const truncatedText = escapeHtml(fieldValue.substring(0, fieldLength) + '...');

                // Calculate HL7 field number (1-indexed)
                // For MSH: fields[0]='MSH', fields[1]=MSH-1, fields[2]=MSH-2, etc.
                // For other segments: fields[0]=segment type, fields[1]=field-1, fields[2]=field-2, etc.
                let hl7FieldNumber;
                if (segment.type === 'MSH') {
                    // MSH: index 0 is segment type (not a field), index 1 is MSH-1
                    hl7FieldNumber = i;
                } else {
                    // Other segments: index 0 is segment type (not a field), index 1 is field-1
                    hl7FieldNumber = i;
                }

                const fieldName = getFieldName(segment.type, hl7FieldNumber);
                const fieldNameHtml = fieldName ? `<span class="field-name">${escapeHtml(fieldName)}</span>` : '';

                // Determine if this field should be highlighted
                const isSelected = selectedFieldValue !== null && fieldValue === selectedFieldValue;
                const isMatching = selectedFieldValue !== null && fieldValue === selectedFieldValue && fieldValue.length > 0;

                // Build field value classes
                let fieldValueClasses = 'field-value';
                if (isSelected) fieldValueClasses += ' selected';
                if (isMatching) fieldValueClasses += ' matching';

                // For long fields, add the long class
                const fieldContentClass = isLong ? 'field-content long' : 'field-content';

                // Data attribute for the raw field value (used for highlight matching)
                const dataFieldValue = fieldValue.replace(/"/g, '&quot;');

                return `
                    <div class="field-item">
                        <span class="field-index">${hl7FieldNumber}:</span>
                        ${fieldNameHtml}
                        <span class="${fieldContentClass}">
                            <span class="${fieldValueClasses}"
                                  data-field-value="${dataFieldValue}"
                                  data-segment-index="${index}"
                                  data-field-index="${i}"
                                  onclick="selectFieldForHighlight(this, event)"
                                  title="Click to highlight matching values${isLong ? ' (click again to expand)' : ''}"
                                  ${isLong ? `data-full="${fullField}" data-truncated="${truncatedText}"` : ''}>${isLong ? truncatedText : fullField}</span>
                        </span>
                        <span class="field-copy">
                            <span class="copy-icon" onclick="copyFieldToClipboard(${index}, ${i}, event)" title="Copy field to clipboard">
                                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                    <rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect>
                                    <path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path>
                                </svg>
                            </span>
                        </span>
                    </div>
                `;
            }).join('');

            detailDiv.innerHTML = segmentHeader + fieldsHtml;
            detailDiv.style.display = 'block';
        }

        function copySegmentToClipboard(segmentIndex, event) {
            if (event) {
                event.stopPropagation();
            }
            const segment = parsedSegments[segmentIndex];
            if (segment && segment.raw) {
                navigator.clipboard.writeText(segment.raw).then(() => {
                    showToast('Segment copied to clipboard', 'success');
                }).catch(err => {
                    showToast('Failed to copy segment', 'error');
                });
            }
        }

        function copyFieldToClipboard(segmentIndex, fieldIndex, event) {
            if (event) {
                event.stopPropagation();
            }
            const segment = parsedSegments[segmentIndex];
            if (segment && segment.fields && segment.fields[fieldIndex] !== undefined) {
                const fieldValue = segment.fields[fieldIndex];
                // Calculate HL7 field number for display
                const hl7FieldNumber = segment.type === 'MSH' ? fieldIndex : fieldIndex;
                navigator.clipboard.writeText(fieldValue).then(() => {
                    showToast(`Field ${hl7FieldNumber} copied to clipboard`, 'success');
                }).catch(err => {
                    showToast('Failed to copy field', 'error');
                });
            }
        }

        function copyPropertyToClipboard(event) {
            if (event) {
                event.stopPropagation();
            }
            const button = event.currentTarget;
            const docIndex = parseInt(button.dataset.documentIndex);
            const propertyKey = button.dataset.propertyKey;
            
            if (docIndex !== undefined && extractedDocuments[docIndex] && extractedDocuments[docIndex].properties) {
                const propertyValue = extractedDocuments[docIndex].properties[propertyKey];
                if (propertyValue !== undefined) {
                    navigator.clipboard.writeText(String(propertyValue)).then(() => {
                        showToast(`${propertyKey} copied to clipboard`, 'success');
                    }).catch(err => {
                        showToast('Failed to copy property', 'error');
                    });
                }
            }
        }

        function toggleFieldExpand(element) {
            if (element.classList.contains('expanded')) {
                element.classList.remove('expanded');
                element.textContent = element.dataset.truncated;
            } else {
                element.classList.add('expanded');
                element.textContent = element.dataset.full;
            }
        }

        // Field highlight selection functions
        function selectFieldForHighlight(element, event) {
            event.stopPropagation();

            const fieldValue = element.dataset.fieldValue;
            const segmentIndex = parseInt(element.dataset.segmentIndex);
            const fieldIndex = parseInt(element.dataset.fieldIndex);

            // If this is a long field and user clicks again, toggle expand
            if (element.dataset.full && element.classList.contains('selected')) {
                if (element.classList.contains('expanded')) {
                    element.classList.remove('expanded');
                    element.textContent = element.dataset.truncated;
                } else {
                    element.classList.add('expanded');
                    element.textContent = element.dataset.full;
                }
                return;
            }

            // Don't highlight empty or very short values (like single characters or separators)
            if (!fieldValue || fieldValue.length < 2) {
                showToast('Value too short to highlight', 'error');
                return;
            }

            // If clicking the same field, clear the highlight
            if (selectedFieldValue === fieldValue) {
                clearFieldHighlight();
                return;
            }

            // Set the selected field value
            selectedFieldValue = fieldValue;

            // Highlight all matching values
            highlightMatchingValues();

            // Count matches
            const matchCount = countMatchingFields(fieldValue);
            if (matchCount > 1) {
                showToast(`Found ${matchCount} matching fields`, 'success');
            } else {
                showToast('No other matching fields found', 'success');
            }
        }

        function countMatchingFields(value) {
            let count = 0;
            parsedSegments.forEach(segment => {
                segment.fields.forEach(field => {
                    if (field === value) {
                        count++;
                    }
                });
            });
            return count;
        }

        function highlightMatchingValues() {
            if (!selectedFieldValue) return;

            // Highlight in segment list
            highlightSegmentList();

            // Highlight in currently displayed segment detail
            highlightSegmentDetail();

            // Highlight in paste box
            highlightInPasteBox();

            // Show clear button
            const clearBtn = document.getElementById('clearHighlightBtn');
            if (clearBtn) {
                clearBtn.classList.add('visible');
            }
        }

        function highlightSegmentList() {
            // Mark segments that contain the selected value
            document.querySelectorAll('.segment-item').forEach(item => {
                const index = parseInt(item.dataset.index);
                const segment = parsedSegments[index];

                // Check if this segment contains the selected value
                const hasMatch = segment.fields.some(field => field === selectedFieldValue);

                if (hasMatch) {
                    item.classList.add('has-match');
                } else {
                    item.classList.remove('has-match');
                }
            });
        }

        function highlightSegmentDetail() {
            // Re-render the current segment detail to update highlighting
            const activeSegment = document.querySelector('.segment-item.active');
            if (activeSegment) {
                const index = parseInt(activeSegment.dataset.index);
                showSegmentDetail(index);
            }
        }

        function highlightInPasteBox() {
            const textarea = document.getElementById('hl7Input');
            const backdrop = document.getElementById('inputHighlightBackdrop');

            if (!textarea || !backdrop || !selectedFieldValue) {
                backdrop.innerHTML = '';
                textarea.classList.remove('highlight-active');
                return;
            }

            const text = textarea.value;

            // Escape special regex characters in the search value
            const escapedValue = selectedFieldValue.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');

            // Create regex to find all occurrences
            const regex = new RegExp(escapedValue, 'g');

            // Replace matches with highlighted spans
            const highlightedHtml = escapeHtml(text).replace(
                new RegExp(escapeHtml(selectedFieldValue).replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), 'g'),
                '<span class="hl7-match">$&</span>'
            );

            backdrop.innerHTML = highlightedHtml;
            textarea.classList.add('highlight-active');

            // Sync scroll positions
            syncTextareaScroll();
        }

        function syncTextareaScroll() {
            const textarea = document.getElementById('hl7Input');
            const backdrop = document.getElementById('inputHighlightBackdrop');

            if (textarea && backdrop) {
                backdrop.scrollTop = textarea.scrollTop;
                backdrop.scrollLeft = textarea.scrollLeft;
            }
        }

        function clearFieldHighlight() {
            selectedFieldValue = null;

            // Remove highlighting from segment list
            document.querySelectorAll('.segment-item.has-match').forEach(item => {
                item.classList.remove('has-match');
            });

            // Re-render segment detail to remove highlighting
            highlightSegmentDetail();

            // Clear paste box highlighting
            const textarea = document.getElementById('hl7Input');
            const backdrop = document.getElementById('inputHighlightBackdrop');

            if (backdrop) {
                backdrop.innerHTML = '';
            }
            if (textarea) {
                textarea.classList.remove('highlight-active');
            }

            // Hide clear button
            const clearBtn = document.getElementById('clearHighlightBtn');
            if (clearBtn) {
                clearBtn.classList.remove('visible');
            }
        }

        // Sync scroll on textarea scroll
        document.addEventListener('DOMContentLoaded', () => {
            const textarea = document.getElementById('hl7Input');
            if (textarea) {
                textarea.addEventListener('scroll', syncTextareaScroll);
                textarea.addEventListener('input', () => {
                    // Clear highlights when text changes
                    if (selectedFieldValue) {
                        clearFieldHighlight();
                    }
                });
            }
        });

        function renderDocuments() {
            const section = document.getElementById('documentsSection');
            const grid = document.getElementById('documentGrid');
            const countEl = document.getElementById('docCount');

            if (extractedDocuments.length === 0) {
                section.style.display = 'none';
                return;
            }

            section.style.display = 'block';
            countEl.textContent = extractedDocuments.length;

            grid.innerHTML = extractedDocuments.map((doc, i) => {
                const mimeType = getMimeType(doc.type);
                const dataUrl = `data:${mimeType};base64,${doc.data}`;

                let preview = '';
                const imageTypes = ['jpeg', 'jpg', 'png', 'gif', 'tiff', 'tif', 'svg'];
                const audioTypes = ['mp3', 'wav', 'wave'];
                const videoTypes = ['mp4'];
                const documentTypes = ['pdf', 'doc', 'docx', 'rtf', 'html', 'htm', 'xml'];
                const archiveTypes = ['zip'];
                const medicalTypes = ['dicom', 'dcm', 'hl7-scp-ecg'];

                if (imageTypes.includes(doc.type)) {
                    preview = `<img src="${dataUrl}" alt="Document ${i + 1}" onclick="viewDocument(${i})" style="cursor: pointer;">`;
                } else if (audioTypes.includes(doc.type)) {
                    preview = `
                        <div class="pdf-placeholder">
                            <div class="pdf-icon">ðŸŽµ</div>
                            <span>Audio File</span>
                            <audio controls style="width: 100%; margin-top: 0.5rem;">
                                <source src="${dataUrl}" type="${mimeType}">
                            </audio>
                        </div>
                    `;
                } else if (videoTypes.includes(doc.type)) {
                    preview = `
                        <div class="pdf-placeholder">
                            <div class="pdf-icon">ðŸŽ¬</div>
                            <span>Video File</span>
                            <video controls style="width: 100%; max-height: 200px; margin-top: 0.5rem;">
                                <source src="${dataUrl}" type="${mimeType}">
                            </video>
                        </div>
                    `;
                } else if (documentTypes.includes(doc.type)) {
                    const icon = doc.type === 'pdf' ? 'ðŸ“„' : doc.type === 'html' || doc.type === 'htm' ? 'ðŸŒ' : 'ðŸ“';
                    preview = `
                        <div class="pdf-placeholder">
                            <div class="pdf-icon">${icon}</div>
                            <span>${doc.type.toUpperCase()} Document</span>
                            <button class="btn-secondary" onclick="viewDocument(${i})">View Document</button>
                        </div>
                    `;
                } else if (archiveTypes.includes(doc.type)) {
                    preview = `
                        <div class="pdf-placeholder">
                            <div class="pdf-icon">ðŸ“¦</div>
                            <span>ZIP Archive</span>
                            <button class="btn-secondary" onclick="downloadDocument(${i})">Download</button>
                        </div>
                    `;
                } else if (medicalTypes.includes(doc.type)) {
                    preview = `
                        <div class="pdf-placeholder">
                            <div class="pdf-icon">ðŸ¥</div>
                            <span>${doc.type.toUpperCase()} File</span>
                            <button class="btn-secondary" onclick="downloadDocument(${i})">Download</button>
                        </div>
                    `;
                } else {
                    preview = `
                        <div class="pdf-placeholder">
                            <div class="pdf-icon">ðŸ“„</div>
                            <span>${doc.type.toUpperCase()} File</span>
                            <button class="btn-secondary" onclick="downloadDocument(${i})">Download</button>
                        </div>
                    `;
                }

                // Format properties for display (up to 5)
                let propertiesHtml = '';
                if (doc.properties && Object.keys(doc.properties).length > 0) {
                    const props = Object.entries(doc.properties).slice(0, 5);
                    propertiesHtml = `
                        <div class="document-properties" style="margin-top: 0.75rem; padding-top: 0.75rem; border-top: 1px solid var(--border);">
                            <div style="font-size: 0.75rem; color: var(--text-secondary); margin-bottom: 0.5rem; font-weight: 600; text-transform: uppercase; letter-spacing: 0.05em;">Properties</div>
                            ${props.map(([key, value]) => {
                                const valueStr = String(value);
                                return `
                                <div style="font-size: 0.8rem; margin-bottom: 0.4rem; display: flex; align-items: center; gap: 0.5rem;">
                                    <span style="color: var(--text-secondary); flex-shrink: 0;">${escapeHtml(key)}:</span>
                                    <span style="color: var(--text-primary); flex: 1; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;" title="${escapeHtml(valueStr)}">${escapeHtml(truncate(valueStr, 40))}</span>
                                    <span class="copy-icon" onclick="copyPropertyToClipboard(event)" data-document-index="${i}" data-property-key="${escapeHtml(key)}" title="Copy ${escapeHtml(key)} to clipboard" style="flex-shrink: 0; padding: 0.2rem 0.4rem; font-size: 0.7rem;">
                                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                            <rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect>
                                            <path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path>
                                        </svg>
                                    </span>
                                </div>
                            `;
                            }).join('')}
                        </div>
                    `;
                }

                return `
                    <div class="document-card">
                        <div class="document-preview">
                            ${preview}
                        </div>
                        <div class="document-info">
                            <span class="document-type type-${doc.type}">${doc.type.toUpperCase()}</span>
                            <div class="document-meta">
                                <span>OBX Segment #${doc.segmentIndex + 1}</span>
                                <span>Size: ~${doc.size} KB</span>
                                ${doc.obsIdentifier ? `<span>ID: ${escapeHtml(truncate(doc.obsIdentifier, 30))}</span>` : ''}
                            </div>
                            ${propertiesHtml}
                            <div class="document-actions">
                                <button class="btn-secondary" onclick="downloadDocument(${i})">
                                    Download
                                </button>
                                <button class="btn-primary" onclick="viewDocument(${i})">
                                    View
                                </button>
                            </div>
                        </div>
                    </div>
                `;
            }).join('');
        }

        function getMimeType(type) {
            const types = {
                jpeg: 'image/jpeg',
                jpg: 'image/jpeg',
                png: 'image/png',
                pdf: 'application/pdf',
                gif: 'image/gif',
                tiff: 'image/tiff',
                tif: 'image/tiff',
                rtf: 'application/rtf',
                html: 'text/html',
                htm: 'text/html',
                zip: 'application/zip',
                xml: 'application/xml',
                svg: 'image/svg+xml',
                dicom: 'application/dicom',
                dcm: 'application/dicom',
                doc: 'application/msword',
                docx: 'application/vnd.openxmlformats-officedocument.wordprocessingml.document',
                mp3: 'audio/mpeg',
                wav: 'audio/wav',
                wave: 'audio/wav',
                mp4: 'video/mp4',
                'hl7-scp-ecg': 'application/x-hl7-scp-ecg'
            };
            return types[type] || 'application/octet-stream';
        }

        function viewDocument(index) {
            const doc = extractedDocuments[index];
            const modal = document.getElementById('imageModal');
            const modalBody = document.getElementById('modalBody');
            const mimeType = getMimeType(doc.type);
            const dataUrl = `data:${mimeType};base64,${doc.data}`;

            const imageTypes = ['jpeg', 'jpg', 'png', 'gif', 'tiff', 'tif', 'svg'];
            const audioTypes = ['mp3', 'wav', 'wave'];
            const videoTypes = ['mp4'];
            const documentTypes = ['pdf', 'html', 'htm', 'xml'];
            const viewableTypes = ['rtf', 'doc', 'docx'];

            if (imageTypes.includes(doc.type)) {
                modalBody.innerHTML = `<img src="${dataUrl}" alt="Document">`;
            } else if (audioTypes.includes(doc.type)) {
                modalBody.innerHTML = `
                    <div style="background: var(--bg-secondary); padding: 2rem; border-radius: 8px; text-align: center;">
                        <h3 style="margin-bottom: 1rem; color: var(--text-primary);">Audio Player</h3>
                        <audio controls style="width: 100%; max-width: 600px;">
                            <source src="${dataUrl}" type="${mimeType}">
                        </audio>
                    </div>
                `;
            } else if (videoTypes.includes(doc.type)) {
                modalBody.innerHTML = `
                    <div style="background: var(--bg-secondary); padding: 2rem; border-radius: 8px; text-align: center;">
                        <h3 style="margin-bottom: 1rem; color: var(--text-primary);">Video Player</h3>
                        <video controls style="width: 100%; max-width: 800px; max-height: 70vh;">
                            <source src="${dataUrl}" type="${mimeType}">
                        </video>
                    </div>
                `;
            } else if (doc.type === 'pdf') {
                modalBody.innerHTML = `<iframe src="${dataUrl}"></iframe>`;
            } else if (doc.type === 'html' || doc.type === 'htm') {
                modalBody.innerHTML = `<iframe src="${dataUrl}" style="width: 80vw; height: 85vh;"></iframe>`;
            } else if (doc.type === 'xml' || doc.type === 'svg') {
                modalBody.innerHTML = `<iframe src="${dataUrl}" style="width: 80vw; height: 85vh;"></iframe>`;
            } else if (viewableTypes.includes(doc.type)) {
                // For RTF, DOC, DOCX - show download option since browsers can't display them directly
                modalBody.innerHTML = `
                    <div style="background: var(--bg-secondary); padding: 2rem; border-radius: 8px; text-align: center; color: var(--text-primary);">
                        <h3 style="margin-bottom: 1rem;">${doc.type.toUpperCase()} Document</h3>
                        <p style="margin-bottom: 1.5rem; color: var(--text-secondary);">This document type cannot be previewed in the browser.</p>
                        <button class="btn-primary" onclick="downloadDocument(${index}); closeModal();">Download Document</button>
                    </div>
                `;
            } else {
                // For other types (zip, dicom, etc.) - show download option
                modalBody.innerHTML = `
                    <div style="background: var(--bg-secondary); padding: 2rem; border-radius: 8px; text-align: center; color: var(--text-primary);">
                        <h3 style="margin-bottom: 1rem;">${doc.type.toUpperCase()} File</h3>
                        <p style="margin-bottom: 1.5rem; color: var(--text-secondary);">This file type cannot be previewed in the browser.</p>
                        <button class="btn-primary" onclick="downloadDocument(${index}); closeModal();">Download File</button>
                    </div>
                `;
            }

            modal.classList.add('active');
        }

        function closeModal() {
            document.getElementById('imageModal').classList.remove('active');
            document.getElementById('modalBody').innerHTML = '';
        }

        function downloadDocument(index) {
            const doc = extractedDocuments[index];
            const mimeType = getMimeType(doc.type);
            
            // Map types to file extensions
            const extensionMap = {
                jpeg: 'jpg',
                jpg: 'jpg',
                png: 'png',
                pdf: 'pdf',
                gif: 'gif',
                tiff: 'tiff',
                tif: 'tif',
                rtf: 'rtf',
                html: 'html',
                htm: 'htm',
                zip: 'zip',
                xml: 'xml',
                svg: 'svg',
                dicom: 'dcm',
                dcm: 'dcm',
                doc: 'doc',
                docx: 'docx',
                mp3: 'mp3',
                wav: 'wav',
                wave: 'wav',
                mp4: 'mp4',
                'hl7-scp-ecg': 'ecg'
            };
            
            const extension = extensionMap[doc.type] || doc.type;

            const link = document.createElement('a');
            link.href = `data:${mimeType};base64,${doc.data}`;
            link.download = `document_${index + 1}.${extension}`;
            link.click();

            showToast('Document downloaded', 'success');
        }

        function createImageWithText(text, format) {
            // Create a canvas to draw the image
            const canvas = document.createElement('canvas');
            canvas.width = 120;
            canvas.height = 40;
            const ctx = canvas.getContext('2d');
            
            // Set background color
            ctx.fillStyle = '#1a1a2e';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Set text style - pixel/monospace font
            ctx.fillStyle = '#f1f5f9';
            ctx.font = 'bold 24px "Courier New", Courier, monospace';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            
            // Draw text
            ctx.fillText(text, canvas.width / 2, canvas.height / 2);
            
            // Convert to base64
            if (format === 'png') {
                return canvas.toDataURL('image/png').split(',')[1];
            } else if (format === 'jpeg' || format === 'jpg') {
                return canvas.toDataURL('image/jpeg', 0.9).split(',')[1];
            }
            return null;
        }

        function createPingSound() {
            // Generate a pleasant ping/beep sound as WAV file
            // Frequency: 800Hz (pleasant mid-tone)
            // Duration: 0.3 seconds
            const sampleRate = 44100;
            const frequency = 800;
            const duration = 0.3;
            const numSamples = Math.floor(sampleRate * duration);
            const samples = new Float32Array(numSamples);
            
            // Generate sine wave with envelope (quick attack, exponential decay)
            for (let i = 0; i < numSamples; i++) {
                const t = i / sampleRate;
                // Create envelope: quick attack (0.01s), then exponential decay
                let envelope;
                if (t < 0.01) {
                    envelope = t / 0.01; // Linear attack
                } else {
                    envelope = Math.exp(-(t - 0.01) * 8); // Exponential decay
                }
                // Generate sine wave
                samples[i] = Math.sin(2 * Math.PI * frequency * t) * envelope * 0.5;
            }
            
            // Convert to 16-bit PCM
            const pcm = new Int16Array(numSamples);
            for (let i = 0; i < numSamples; i++) {
                const s = Math.max(-1, Math.min(1, samples[i]));
                pcm[i] = s < 0 ? s * 0x8000 : s * 0x7FFF;
            }
            
            // Create WAV file header
            const dataLength = numSamples * 2; // 2 bytes per sample (16-bit)
            const buffer = new ArrayBuffer(44 + dataLength);
            const view = new DataView(buffer);
            
            // RIFF header
            const writeString = (offset, string) => {
                for (let i = 0; i < string.length; i++) {
                    view.setUint8(offset + i, string.charCodeAt(i));
                }
            };
            
            writeString(0, 'RIFF');
            view.setUint32(4, 36 + dataLength, true);
            writeString(8, 'WAVE');
            writeString(12, 'fmt ');
            view.setUint32(16, 16, true); // fmt chunk size
            view.setUint16(20, 1, true); // audio format (PCM)
            view.setUint16(22, 1, true); // num channels (mono)
            view.setUint32(24, sampleRate, true);
            view.setUint32(28, sampleRate * 2, true); // byte rate
            view.setUint16(32, 2, true); // block align
            view.setUint16(34, 16, true); // bits per sample
            writeString(36, 'data');
            view.setUint32(40, dataLength, true);
            
            // Write PCM data
            const pcmView = new Int16Array(buffer, 44);
            pcmView.set(pcm);
            
            // Convert to base64
            const bytes = new Uint8Array(buffer);
            let binary = '';
            for (let i = 0; i < bytes.length; i++) {
                binary += String.fromCharCode(bytes[i]);
            }
            return btoa(binary);
        }

        function loadSample() {
            // Generate PNG and JPEG images with text in pixel font
            const samplePng = createImageWithText('PNG', 'png');
            const sampleJpeg = createImageWithText('JPEG', 'jpeg');

            // Generate pleasant ping/beep sound as WAV
            const sampleWav = createPingSound();

            const sample = `MSH|^~\\&|SENDING_APP|SENDING_FACILITY|RECEIVING_APP|RECEIVING_FACILITY|20231215120000||ORU^R01|MSG00001|P|2.4
PID|1||12345^^^Hospital^MR||Doe^John^A||19800101|M|||123 Main St^^City^ST^12345
OBR|1|ORD001|ACC001|85025^CBC^LN|||20231215100000
OBX|1|ED|PDF^Report||^application^pdf^Base64^JVBERi0xLjQKMSAwIG9iago8PAovVHlwZSAvQ2F0YWxvZwovUGFnZXMgMiAwIFIKPj4KZW5kb2JqCjIgMCBvYmoKPDwKL1R5cGUgL1BhZ2VzCi9LaWRzIFszIDAgUl0KL0NvdW50IDEKL01lZGlhQm94IFswIDAgNjEyIDc5Ml0KPj4KZW5kb2JqCjMgMCBvYmoKPDwKL1R5cGUgL1BhZ2UKL1BhcmVudCAyIDAgUgovUmVzb3VyY2VzIDw8Ci9Gb250IDw8Ci9GMSA0IDAgUgo+Pgo+PgovQ29udGVudHMgNSAwIFIKPj4KZW5kb2JqCjQgMCBvYmoKPDwKL1R5cGUgL0ZvbnQKL1N1YnR5cGUgL1R5cGUxCi9CYXNlRm9udCAvSGVsdmV0aWNhCj4+CmVuZG9iago1IDAgb2JqCjw8Ci9MZW5ndGggNDQKPj4Kc3RyZWFtCkJUCi9GMSAxOCBUZgoxMDAgNzAwIFRkCihITDcgUmVwb3J0KSBUagpFVAplbmRzdHJlYW0KZW5kb2JqCnhyZWYKMCA2CjAwMDAwMDAwMDAgNjU1MzUgZiAKMDAwMDAwMDAwOSAwMDAwMCBuIAowMDAwMDAwMDU4IDAwMDAwIG4gCjAwMDAwMDAxNDcgMDAwMDAgbiAKMDAwMDAwMDI2NiAwMDAwMCBuIAowMDAwMDAwMzQzIDAwMDAwIG4gCnRyYWlsZXIKPDwKL1NpemUgNgovUm9vdCAxIDAgUgo+PgpzdGFydHhyZWYKNDM3CiUlRU9G||||||F
OBX|2|ED|PNG^Image^Scan||^image^png^Base64^${samplePng}||||||F
OBX|3|ED|JPEG^Photo||^image^jpeg^Base64^${sampleJpeg}||||||F
OBX|4|ED|WAV^Audio^Recording||^audio^wav^Base64^${sampleWav}||||||F
OBX|5|NM|WBC^White Blood Cell Count||7.5|10*3/uL|4.5-11.0|N|||F
OBX|6|NM|RBC^Red Blood Cell Count||4.8|10*6/uL|4.2-5.9|N|||F`;

            document.getElementById('hl7Input').value = sample;
            showToast('Sample message loaded', 'success');
        }

        function clearAll() {
            // Clear field highlights first
            clearFieldHighlight();

            document.getElementById('hl7Input').value = '';
            parsedSegments = [];
            extractedDocuments = [];
            document.getElementById('resultsContent').innerHTML = `
                <div class="empty-state">
                    <div class="empty-state-icon">ðŸ“‹</div>
                    <h3>No Message Parsed</h3>
                    <p>Paste an HL7 message and click "Parse Message" to view segments and extract embedded documents.</p>
                </div>
            `;
            document.getElementById('documentsSection').style.display = 'none';
            const popOutBtn = document.getElementById('popOutBtn');
            if (popOutBtn) {
                popOutBtn.style.display = 'none';
            }
            showToast('Cleared', 'success');
        }

        function openResultsOverlay() {
            if (parsedSegments.length === 0) {
                showToast('No parsed results to display', 'error');
                return;
            }

            const modal = document.getElementById('resultsOverlay');
            const modalContent = document.getElementById('resultsOverlayContent');
            
            // Render results view similar to regular panel but larger
            const obxCount = parsedSegments.filter(s => s.type === 'OBX').length;
            const docCount = extractedDocuments.length;

            let html = `
                <div class="overlay-header">
                    <h2>Parsed Results - Full View</h2>
                    <button class="modal-close" onclick="closeResultsOverlay()">&times;</button>
                </div>
                <div class="overlay-stats-bar">
                    <div class="stat-item">
                        <div class="stat-value">${parsedSegments.length}</div>
                        <div class="stat-label">Segments</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value">${obxCount}</div>
                        <div class="stat-label">OBX Segments</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value">${docCount}</div>
                        <div class="stat-label">Documents Found</div>
                    </div>
                </div>
                <div class="overlay-segments-container">
                    <div class="overlay-segment-list" id="overlaySegmentList">
                        ${parsedSegments.map((seg, i) => `
                            <div class="overlay-segment-item ${seg.type === 'OBX' ? 'obx-segment' : ''}"
                                 onclick="showOverlaySegmentDetail(${i})"
                                 data-index="${i}">
                                <span class="segment-tag">${seg.type}</span>
                                <span>${truncate(seg.raw, 120)}</span>
                            </div>
                        `).join('')}
                    </div>
                    <div class="overlay-segment-detail" id="overlaySegmentDetail" style="display: none;"></div>
                </div>
            `;

            modalContent.innerHTML = html;
            modal.classList.add('active');
        }

        function showOverlaySegmentDetail(index) {
            const segment = parsedSegments[index];
            const detailDiv = document.getElementById('overlaySegmentDetail');

            // Update active state
            document.querySelectorAll('.overlay-segment-item').forEach(el => el.classList.remove('active'));
            document.querySelector(`.overlay-segment-item[data-index="${index}"]`).classList.add('active');

            // Create segment header with copy icon
            const segmentHeader = `
                <div class="segment-header">
                    <div class="segment-type-header">
                        <span class="field-highlight">${escapeHtml(segment.type)}</span>
                        <span style="color: var(--text-secondary); font-size: 0.75rem; margin-left: 0.5rem;">HL7 v${hl7Version}</span>
                        <span class="copy-icon" onclick="copySegmentToClipboard(${index}, event)" title="Copy segment to clipboard">
                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                <rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect>
                                <path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path>
                            </svg>
                        </span>
                    </div>
                </div>
            `;

            // Format all fields with copy icons
            const fieldLength = 200; // Longer field display in overlay
            const fieldsHtml = segment.fields.map((field, i) => {
                const fieldValue = field || '';
                const isLong = fieldValue.length > fieldLength;
                const fullField = escapeHtml(fieldValue);
                const truncatedText = escapeHtml(fieldValue.substring(0, fieldLength) + '...');

                // Calculate HL7 field number (1-indexed)
                let hl7FieldNumber;
                if (segment.type === 'MSH') {
                    hl7FieldNumber = i;
                } else {
                    hl7FieldNumber = i;
                }

                const fieldName = getFieldName(segment.type, hl7FieldNumber);
                const fieldNameHtml = fieldName ? `<span class="field-name">${escapeHtml(fieldName)}</span>` : '';

                // Determine if this field should be highlighted
                const isSelected = selectedFieldValue !== null && fieldValue === selectedFieldValue;
                const isMatching = selectedFieldValue !== null && fieldValue === selectedFieldValue && fieldValue.length > 0;

                // Build field value classes
                let fieldValueClasses = 'field-value';
                if (isSelected) fieldValueClasses += ' selected';
                if (isMatching) fieldValueClasses += ' matching';

                // For long fields, add the long class
                const fieldContentClass = isLong ? 'field-content long' : 'field-content';

                // Data attribute for the raw field value (used for highlight matching)
                const dataFieldValue = fieldValue.replace(/"/g, '&quot;');

                return `
                    <div class="field-item">
                        <span class="field-index">${hl7FieldNumber}:</span>
                        ${fieldNameHtml}
                        <span class="${fieldContentClass}">
                            <span class="${fieldValueClasses}"
                                  data-field-value="${dataFieldValue}"
                                  data-segment-index="${index}"
                                  data-field-index="${i}"
                                  onclick="selectFieldForHighlightOverlay(this, event)"
                                  title="Click to highlight matching values${isLong ? ' (click again to expand)' : ''}"
                                  ${isLong ? `data-full="${fullField}" data-truncated="${truncatedText}"` : ''}>${isLong ? truncatedText : fullField}</span>
                        </span>
                        <span class="field-copy">
                            <span class="copy-icon" onclick="copyFieldToClipboard(${index}, ${i}, event)" title="Copy field to clipboard">
                                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                    <rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect>
                                    <path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path>
                                </svg>
                            </span>
                        </span>
                    </div>
                `;
            }).join('');

            detailDiv.innerHTML = segmentHeader + fieldsHtml;
            detailDiv.style.display = 'block';
        }

        // Overlay version of field highlight selection
        function selectFieldForHighlightOverlay(element, event) {
            event.stopPropagation();

            const fieldValue = element.dataset.fieldValue;

            // If this is a long field and user clicks again, toggle expand
            if (element.dataset.full && element.classList.contains('selected')) {
                if (element.classList.contains('expanded')) {
                    element.classList.remove('expanded');
                    element.textContent = element.dataset.truncated;
                } else {
                    element.classList.add('expanded');
                    element.textContent = element.dataset.full;
                }
                return;
            }

            // Don't highlight empty or very short values
            if (!fieldValue || fieldValue.length < 2) {
                showToast('Value too short to highlight', 'error');
                return;
            }

            // If clicking the same field, clear the highlight
            if (selectedFieldValue === fieldValue) {
                clearFieldHighlightOverlay();
                return;
            }

            // Set the selected field value
            selectedFieldValue = fieldValue;

            // Highlight all matching values in overlay
            highlightOverlaySegmentList();
            highlightOverlaySegmentDetail();
            highlightInPasteBox();

            // Show clear button in main view too
            const clearBtn = document.getElementById('clearHighlightBtn');
            if (clearBtn) {
                clearBtn.classList.add('visible');
            }

            // Count matches
            const matchCount = countMatchingFields(fieldValue);
            if (matchCount > 1) {
                showToast(`Found ${matchCount} matching fields`, 'success');
            } else {
                showToast('No other matching fields found', 'success');
            }
        }

        function highlightOverlaySegmentList() {
            // Mark segments that contain the selected value in overlay
            document.querySelectorAll('.overlay-segment-item').forEach(item => {
                const index = parseInt(item.dataset.index);
                const segment = parsedSegments[index];

                const hasMatch = segment.fields.some(field => field === selectedFieldValue);

                if (hasMatch) {
                    item.classList.add('has-match');
                } else {
                    item.classList.remove('has-match');
                }
            });
        }

        function highlightOverlaySegmentDetail() {
            const activeSegment = document.querySelector('.overlay-segment-item.active');
            if (activeSegment) {
                const index = parseInt(activeSegment.dataset.index);
                showOverlaySegmentDetail(index);
            }
        }

        function clearFieldHighlightOverlay() {
            selectedFieldValue = null;

            // Remove highlighting from overlay segment list
            document.querySelectorAll('.overlay-segment-item.has-match').forEach(item => {
                item.classList.remove('has-match');
            });

            // Re-render overlay segment detail
            highlightOverlaySegmentDetail();

            // Also clear main view and paste box
            document.querySelectorAll('.segment-item.has-match').forEach(item => {
                item.classList.remove('has-match');
            });
            highlightSegmentDetail();

            const textarea = document.getElementById('hl7Input');
            const backdrop = document.getElementById('inputHighlightBackdrop');
            if (backdrop) backdrop.innerHTML = '';
            if (textarea) textarea.classList.remove('highlight-active');

            const clearBtn = document.getElementById('clearHighlightBtn');
            if (clearBtn) clearBtn.classList.remove('visible');
        }

        function closeResultsOverlay() {
            document.getElementById('resultsOverlay').classList.remove('active');
        }

        function truncate(str, len) {
            if (!str) return '';
            return str.length > len ? str.substring(0, len) + '...' : str;
        }

        function escapeHtml(str) {
            if (!str) return '';
            const div = document.createElement('div');
            div.textContent = str;
            return div.innerHTML;
        }

        function showToast(message, type = 'success') {
            const toast = document.getElementById('toast');
            toast.textContent = message;
            toast.className = `toast ${type} show`;
            setTimeout(() => {
                toast.classList.remove('show');
            }, 3000);
        }

        // Close modal on escape key
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') {
                closeModal();
                closeResultsOverlay();
            }
        });

        // Close modal on backdrop click
        document.getElementById('imageModal').addEventListener('click', (e) => {
            if (e.target.id === 'imageModal') {
                closeModal();
            }
        });

        // Close results overlay on backdrop click
        document.getElementById('resultsOverlay').addEventListener('click', (e) => {
            if (e.target.id === 'resultsOverlay') {
                closeResultsOverlay();
            }
        });

        // Set version in header and footer
        document.addEventListener('DOMContentLoaded', () => {
            const versionEl = document.getElementById('version');
            if (versionEl) {
                versionEl.textContent = APP_VERSION;
            }
            const headerVersionEl = document.getElementById('headerVersion');
            if (headerVersionEl) {
                headerVersionEl.textContent = APP_VERSION;
            }
        });
    </script>
</body>
</html>
